 - [유니티 최적화_메타메타몽몽](https://metamon9.tistory.com/category/PROGRAMMING/Unity)

# 1.성능 프로파일링 유의사항
 - [링크](https://www.youtube.com/watch?v=d_0uDfNEOk8)

### 최적화

##### 타겟 플랫폼과 기능 상세의 선행 조사 필수
 - 성능 대비 좋은 퀄리티를 보여주는 것이 최적화.
   - 무조건 좋은 퀄리티를 보여주는 것은 높은 사양을 요구하게 됨.
 - 따라서 타겟 플렛폼과 기능 상세의 선행 조사는 필수임
   - 타겟을 정확히 잡고 그 타겟에 맞는 좋은 퀄리티를 보여주는 것이 최적화.

##### 프로토타이핑 후 다시 개발
 - 프로토타이핑 단계에서는 최적화를 절대 하면 안 된다.
   - 프로토타이핑 단계는 게임의 컨셉, 재미, 발전 방향 등을 미리 보는 단계
   - 따라서 구현에만 집중해 빨리 만들어 빨리 테스트하는 것에 초점을 맞춰야 한다.
   - 프로토타이핑 이후 본 개발에 들어가면 처음부터 다시 만들어야 됨.
 - 물론 실전으로 들어가면 프로토타입 때 만든 코드를 출시시킬 수도 있지만, 이론상으로는 프로토타입과 프로덕션을 분리해야 한다.

##### 프로파일링
 - 최적화에서 가장 중요한 것은 프로파일링. 프로파일링을 거치고 나서 최적화를 진행해야 한다.
   - 프로파일링은 병목을 탐지하고 병목을 제거하는 것을 반복하는 것
 - 프로파일링과 최적화 단계는 프로덕션 단계에서 주기적으로 해 주어야 한다.
   - 완성 직전에 프로파일링에서 문제가 생기면 처음부터 다시 갈아엎어야 될 수도 있다.
   - 따라서 빌드 자동화 및 QA 프로세스의 정립이 필수적이다.
 - 프로파일링의 주의 사항은 다음과 같다.
   - 추측에 의한 최적화는 절대 금지. 적절한 프로파일링으로 원인을 찾아낸 후 최적화를 해야 한다.
   - 디버거/프로파일러 툴의 적극적인 활용
   - 유니티 에디터에서의 프로파일링은 단순 참고용
   - 타겟 플랫폼에서의 프로파일링은 필수
   - 자동화된 테스팅 환경 구축(벤치마커 등)

##### 쓰로틀링
 - 모바일 환경 성능에서 매우 중요한 요소이다.
 - PC나 콘솔과 다르게 능동적으로 열을 식혀줄 요소가 없기 때문에 모바일 자체에서 작업에 제한을 두어 열을 식히는 상태이다.
 - 모바일 상태에서 프로파일링을 하다가 쓰로틀링에 의해 예상치 못한 성능 저하를 맛볼 수 있기 때문에 이를 유의하며 최적화를 해야 한다.

##### 기타 성능 관련 설정들
 - 타겟 프레임 레이트, V-Sync 등
   - 해당 설정들에 일부러 제한을 걸고 프로파일링을 할 시 해당 자료를 신뢰할 수 없게 된다.


# 2.유니티 프로파일러와 Xcode Instruments
 - [링크](https://www.youtube.com/watch?v=WncETrdMG0Q)

### 유니티 프로파일러
 - 타임라인을 잘 확인하면 쓰레드의 상관관계를 잘 알 수 있다.
 - 내가 작성한 코드에 프로파일링 태그를 달 수 있다.
   - 이를 이용해 내가 작성한 코드의 성능을 확인할 수 있다.
```
void Example()
{
  // 프로파일러에 SampleName이라는 이름의 오버뷰를 추가
  Profiler.BeginSample("SampleName"); 
  
  // 검사할 코드들

  Profiler.EndSample();
}
```
 - 게임을 만들 때 우리 게임이 CPU 바운드인지, GPU 바운드인지도 잘 확인해야 한다.
   - CPU바운드는 CPU가 병목, GPU바운드는 GPU가 병목
 - 프로파일러를 이용해 바운드 타입을 대략적으로 파악 가능하고, 이를 조치할 수도 있다.
   - 실제로 프로파일러로 측정하기 전까지는 어떠한 병목인지 모른다!

### FPS vs Frame Time
 - FPS는 1초에 몇 프레임이 구현되냐는 뜻, Frame Time은 한 프레임을 구현하는 데에 얼마의 시간이 걸리냐는 뜻

### 프로파일 애널라이저(Profile Analyzer)
 - 프로파일 결과물들을 스냅샷을 찍어 상황을 비교할 수 있는 툴
 - 수정하기 전후의 상황을 비교할 때 사용하기 용이하다.

### Xcode
 - 애플 제품군에서 최고의 프로파일링 툴인 Instruments를 제공한다.
 - 빌드 후 최적화에 용이


# 3.GPU 프로파일링
 - [링크](https://www.youtube.com/watch?v=3-ir52a_ynM)

### GPU 프로파일링
 - GPU 프로파일링은 매우 어렵다.
   - 유니티 프로파일러가 일부 플랫폼에서만 GPU 프로파일링을 제공한다.
   - 모바일 기기에서는 벤더가 제공하는 툴을 사용하던가, 그래픽 설정들을 변경해가며 추측으로 떼우는 수밖에 없다.

### Fillrate
 - Fillrate = 화면의 픽셀 수 * 프래그먼트쉐이더 복잡도 * 오버드로우
   - 이들을 줄이려면 해상도를 낮추거나, 텍스처 퀄리티를 낮추거나, 그릴 객체를 줄이는 것으로 해결할 수 있다.
 - 유니티에서 `Resolution Scaling`옵션의 수치값들을 조정하며 GPU의 부하 상황을 유추할 수 있다.

### 오버드로우
 - 그려져야 되는 것들이 얼마나 중첩되는지에 대한 값, 반투명한 오브젝트들이 중첩될 때 값이 늘어난다.
 - 불투명한 두 오브젝트가 중첩되어 있을 때 유니티는 더 앞에 있는 오브젝트를 먼저 그려 중첩되는 픽셀을 덧그리는 것을 최대한 회피한다.
 - 하지만 반투명한 오브젝트가 중첩되어 있을 경우, 유니티는 어쩔 수 없이 픽셀을 덧그리게 되는데 이것이 오버드로우 부하를 일으킨다.
 - 주로 이펙트에서 오버드로우 부하가 많이 일어나게 된다.
 - 씬 설정으로 오버드로우 상황을 쉽게 확인할 수 있다.

### 업스케일 샘플링
 - https://github.com/ozlael/UpsamplingRenderingDemo
 - 다른 프로세싱 퀄리티를 포기할 수 없으면 결국 해상도를 줄이는 수 밖에 없다.
 - 꼼수로 3D씬의 해상도를 줄이고 UI는 원 해상도로 그릴 수 있다.
   - URP에서는 간단하게 할 수 있다.
 - 모바일 플랫폼에서는 텍스처 퀄리티를 조절하여 픽셀 병목을 완화시키는 것이 좋다.


# 4.텍스처 압축
 - [링크](https://www.youtube.com/watch?v=3_pASBWPovc)

### 텍스처의 포멧
 - 텍스처는 대부분 메모리를 많이 잡아먹는다
 - PNG, JPG같은 일반적인 그래픽 포멧은 오래전 저장장치의 용량을 많이 잡아먹는 BMP 포멧을 대체하기 위해 생겨난 포멧이다.
   - 따라서 GPU는 해당 포멧을 그대로 사용할 수 없으므로 유니티엔진은 일반 사진들을 GPU가 사용할 수 있는 포멧으로 변환해준다.
   - 텍스처 포멧 문서 : https://docs.unity3d.com/kr/2018.4/Manual/class-TextureImporterOverride.html
 - 텍스처 압축 : https://mentum.tistory.com/583

### 텍스처 처리
 - 모든 포맷들이 기본적으로 원 텍스처의 픽셀들을 4개 혹은 그 이상만큼 묶어 압축한다.
   - 따라서 게임에 사용할 텍스처는 2의 n승의 크기로 제공해야 한다.
 - ETC(안드로이드)는 압축한 베이스 컬러에 per-pixel luminance라는 픽셀의 명암을 추가해 결과 이미지를 만들어낸다.
   - 아트가 의도하지 않았던 색상이 결과물로 나올 수 있다.
 - PVRTC(iOS)는 두 종류의 압축한 이미지와 모듈레이션 데이터를 합쳐 결과 이미지를 만들어낸다.
   - 색이 번지는 듯한 결과가 나오기 때문에 도트 형식의 그래픽 스타일이 썩 어울리지 않는다.
 - ASTC는 최신 안드로이드/iOS를 지원하는 포맷으로 4, 6, 8, 10, 12의 블록 크기를 지원한다.
   - UI 이미지는 4x4, 3D 오브젝트 텍스쳐 등에는 6x6, 이펙트 등에는 8x8 이상을 사용하면 좀 더 메모리를 절약할 수 있다.
  

# 5.프레임 디버거
 - [링크](https://www.youtube.com/watch?v=g_ZgPyB9uKw)

### 프레임 디버거
 - 프레임마다 화면에 오브젝트가 그려지는 상황(드로우콜)을 순차적으로 볼 수 있다.
   - 게임에 드로우콜이 많이 발생할 때 어떤 식으로 드로우콜이 이루어지는가를 편하게 확인할 수 있다.
   - 실시간으로 배칭이 깨지는 이유도 프레임 디버거를 통해 확인할 수 있다.
   - 드로우콜과 배칭 : https://everyday-devup.tistory.com/57

### 드로우콜 최적화
 - 각 오브젝트의 스프라이트 렌더러에 일관된 소팅 레이어를 지정해주면(그림자끼리, UI끼리 등) 해당 레이어를 지니고 있는 모든 오브젝트가 일관되게 드로우되므로 드로우 콜을 줄일 수 있다.
   - 스프라이트 패킹(아틀라스)과 더 많은 소팅 레이어로 드로우콜을 많이 줄일 수 있다.


# 6.메모리 프로파일러
 - [링크](https://www.youtube.com/watch?v=myXFh3wjbxA)

### PC와 모바일의 가상 메모리
 - 런타임 성능도 중요하지만, 메모리 또한 매우 중요하다.
   - 모바일쪽은 메모리 쪽이 조악하여 특히 더 중요하다.
 - PC의 가상 메모리는 메모리 용량이 부족할 시 저장장치에 가상으로 메모리를 증설하는 컨셉
   - 메모리 처리 속도가 느려지면서 페이징 등이 발생할 수 있지만, 어쨌든 메모리의 총량은 늘어남
 - 반면에 모바일의 가상 메모리는 다른 애플리케이션들에 할당된 메모리를 최대한 줄이는 방법
   - 따라서 메모리의 총량이 늘어나지 않음
   - 실제로 모바일 개발에서 메모리를 많이 사용하는 로딩 타임때 OS가 강재로 게임을 죽여버리는 경우가 많다.

### 메모리 프로파일러
 - 유니티 패키지 매니저를 이용해 설치할 수 있다.
 - 텍스처, 사운드, 폰트, 스크립트 등 웬만한 힙 메모리를 프로파일링 할 수 있다.

### 메모리 압축법
  - 디바이스가 지원하지 않는 텍스처 압축 포멧으로 게임을 빌드할 경우 압축된 텍스처가 모두 해제되며 메모리를 과도하게 점유할 수 있다.
   - 최신 유니티에서는 각 빌드마다 텍스처 포멧을 명시적으로 지정할 수 있으므로 꼭 지정하자.
   - 스크립트를 이용해 모든 텍스처를 하나의 포멧으로 적용시킬 수 있다. 팀과 잘 대화하며 사용 여부를 결정하자.
 - 오디오클립의 경우 로드 타입을 잘 확인하여 지정해주자.
 - 유니티에는 중복되는 리소스를 하나만 남겨주는 기능이 없다. 따라서 모든 리소스(에셋 번들 포함)는 단 하나씩만 임포트해주자.
 - 메시는 'Read/Write Enabled'를 되도록이면 꺼 주는 것이 낫다.
   - Read/Write Enabled는 스크립트나 API로 메시에 접근할 수 있는지 여부를 설정할 수 있다.
   - 체크 시 출력을 위해 GPU메모리에, 설정을 위해 CPU메모리에 중복되어서 올라가기 때문에 메모리 낭비가 발생한다.
 - 애니메이션 리소스의 경우 머터리얼을 임포트할 필요가 없으니 이도 제한해줄 수 있다.

```
// 텍스처 포멧 지정 스크립트
using UnityEditor;

public class ResourceModifierTest : AssetPostprocessing
{
  void OnPreprocessTexture()
  {
    var importer = (assetImperter as TextureImporter);

    if (importer.textureType == TextureImperterType.Sprite)
    {
      importer.SetPlatformTextureSettings(
        "Android", 1024, TextureImporterFormat.AutomaticCompressed);
      importer.SetPlatformTextureSettings(
        "iPhon", 1024, TextureImporterFormat.AutomaticCompressed);

      importer.SetAllowsAlphaSplitting(true);
      importer.mipmapEnabled = false;
    }
  }
}
```
```
// 메시 최적화 스크립트
using UnityEditor;

public class ResourceModifierTest : AssetPostprocessing
{
  void OnPreprocessModel()
  {
    var importer = (assetImporter as ModelImporter);

    importer.isReadable = false;
    importer.optimizeMesh = true;

    if (assetPath.Contains("@"))
    {
      importer.importMaterials = false;
    }
  }
}
```

# 7.코드 작성 꿀팁
 - [링크](https://www.youtube.com/watch?v=lx5x41WqgMo&t=4s)

### 에셋
 - 에셋 타입별 플랫폼별 세팅
 - 올바른 텍스처 포멧
 - 메시 임포트 옵션
 - 오디오 압축

### 프로그래밍&코드 아키텍처
 - 유니티 플레이엉 루프의 이해
   - Awake, OnEnable, Update 타이밍 등
 - 적절한 targetFrameRate
   - 게임의 Target frame rate와 Fixed Timestep를 잘 조율하는 것도 필요하다.
   - Adaptive Performance를 이용해 부하를 실시간으로 확인해 frame rate를 가변적으로 조절할 수 있음
 - 비동기 로딩 사용
   - `AssetBundle.LoadFromFileAsync()`
   - `AssetBundle.LoadAssetAsync()`
 - 사용하지 않는 Monobehaviour 함수 삭제
   - 유니티는 비어있는 Monobehaviour 함수도 호출한다.
   - 유니티는 C++을 사용하는 엔진부분과, C#을 사용하는 사용자 부분으로 나뉜다.
   - 사용자 부분에서 오브젝트를 만들면, 실은 엔진 부분에서 오브젝트를 만들고 사용자 부분은 이것의 레퍼런스를 받아오는 것이다.
   - 엔진 부분에서는 오브젝트를 Update함수를 갖고 있는 오브젝트, Start함수를 갖고 있는 오브젝트 등 각 메서드를 갖고 있는 오브젝트별로 저장한 후에 해당 메서드가 호출될 시 일괄적으로 처리한다.
   - Monobehaviour함수 호출 시 C++에서 C#으로 오버헤드가 발생하는데 조금씩이지만 이것도 성능에 영향을 끼치게 된다.
   - 단순한 행동을 하는 수만은 오브젝트를 Update할 시에는 오브젝트 내에 Update코드를 작성하는 것 보다 그 오브젝트들을 관리하는 매니저를 만들어 오버헤드를 줄일 수 있다.
 - 비싼 API의 빈번한 호출 주의
   - `GameObject.Find()`, `GameObject.GetComponent()`등 비싼 호출자들은 처음 Start문에서 한 번만 호출하는 것을 추천.
 - 스트링 오퍼레이션 주의
 - Debug.Log() 주의
   - 호출 시 빌드에 포함되므로 출시한 게임의 성능을 저하시킨다.
   - 빌드시 모든 `Debug.Log()`를 지우거나 `[Conditional("ENABLE_LOGS")]`애트리뷰트를 이용하는 등 제한을 두는 것이 낫다.
 - allocating API 주의
   - `Component.GetComponents()`, `Animator.parameters`등 복수의 결과를 배열에 할당해서 반환해주는 함수들 또한 한 번만 호출하는 것을 추천
 - 정적 데이터 파싱 주의
   - XML/JSON형식 등의 정적 데이터를 런타임 도중 파일째로 읽어오는 게 아니라, 스크립터블 오브젝트로 만들어진 결과물을 가져다 쓰도록 하는 것이 성능에 좋다.