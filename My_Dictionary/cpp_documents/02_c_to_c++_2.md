# 2-1 시작에 앞서

## c언어의 복습

### const의 의미
 - const선언에 의해 만들어진 변수를 가리켜 '상수화된 변수'라고 한다.
 - `const int num = 10;` 은 변수 num을 상수화된다는 뜻이다.
 - `const int *ptr = &val1;` 은 포인터 ptr을 이용해 val1의 값을 변경할 수 없다는 뜻이다.
 - `int *const ptr2 = &val2;` 은 포인터 ptr2가 상수화된다는 뜻이다.
 - `const int &const ptr3 = &val3` 은 포인터 ptr3이 상수화되었으며, ptr3을 이용해 val3의 값을 바꿀 수 없다는 뜻이다.

### 실행중인 프로그램의 메모리 공간
 - 실행 중인 프로그램은 운영체제로부터 메모리 공간을 할당 받는데 이는 크게 데이터, 스택, 힙 영역으로 나뉜다.
   - 데이터 : 전역변수가 저장되는 영역
   - 스택 : 지역변수 및 매개변수가 저장되는 영역
   - 힙 : malloc 함수호출에 의해 프로그램이 실행되는 과정에서 동적으로 할당이 이루어지는 영역


# 2-2 새 자료형 bool

## true와 false
 - c와 c++모두 정수 0은 거짓을, 0이 아닌 모든 정수는 참을 의미하는 숫자로 정의한다. 따라서 다음과 같이 상수를 정의하는 것이 보통이다.
 ```
#define TRUE 1
#define FALSE 0
 ```
 - 이러한 방식은 c++에서도 사용할 수 있지만, c++에서는 참과 거짓의 표현을 위한 키워드를 따로 정의하기 때문에 굳이 위의 방식을 쓸 필요가 없다.
 - c++에서 `true`와 `false`는 각각 참과 거짓을 표현하기 위한 1바이트 크기의 데이터이다.
 - 다만 c++에서 이 둘이 정의되기 이전에 참을 표현하기 위해서 1을, 거짓을 표현하기 위해서 0을 사용하였기 때문에, 이 둘을 출력하거나 정수로 형변환을 하면 각각 1과 0으로 변환되도록 정의되어 있다.

## 자료형 bool
 - true와 false는 그 자체로 참과 거짓을 의미하는 데이터이기 때문에, 이들 데이터의 저장을 위한 자료형이 별도로 정의되어 있다.
 - true와 false를 가리켜 bool형 데이터라 하며 bool은 int와 같은 기본자료형이기 때문에 변수 선언, 반환자 선언 등이 가능하다.


# 2-3 참조자(Reference)의 이해
 - 참조자는 포인터에 비유되지만 포인터를 몰라도 이해할 수 있다.
 - 에러코드를 반환하는 포인터와 다르게 참조자는 예외(exception)을 내뱉은다. 따라서 try-catch문으로 참조자에서 발생하는 오류를 잡을 수 있다.

## 참조자의 이해
 - 변수는 할당된 메모리 공간에 붙여진 이름이다. 그리고 그 이름을 이용해 접근이 가능하다.
 - 참조는 할당된 하나의 메모리 공간에 둘 이상의 이름을 부여하게 해주는 것이다. 예시는 다음과 같다.
```
int num1 = 20;
int &num2 = num1;
```
 - `&`연산자는 이미 선언된 변수의 앞에 오면 변수의 주소 값을 반환하는 연산자이지만, 새로 선언되는 변수의 앞에 `&`이 오면 참조자의 선언을 뜻하게 된다.
 - 참조자는 자신이 참조하는 변수를 대신할 수 있는 또 하나의 이름이 된다. 참조자가 가리키는 주소는 변수명이 가리키는 주소와 동일하다. 즉 변수명 대신 참조자를 이용해 값을 출력하거나 바꿀 수도 있다.
 - 전통적으로 c++에서는 참조자를 '변수에 별명을 하나 붙여주는 것'이라 설명한다.

## 참조자의 선언 가능 수와 선언 가능 범위

### 참조자의 선언 가능 수
 - 참조자의 수에는 제한이 없다. 여러 개의 참조자를 선언하면 하나의 메모리 공간에 여러 개의 이름을 붙인 꼴이 된다.
 - 참조자를 대상으로 참조자를 선언하는 것도 가능하다. 이 또한 위와 마찬가지로 제한이 없다.
 - 참조자의 수에는 제한이 없지만, 과한 참조자는 바람직하지 않다.

### 참조자의 선언 가능 범위
 - 참조자는 변수에 대해서만 선언이 가능하고, 선언됨과 동시에 누구를 참조해야 한다.
 - 참조자는 변수에 또 다른 이름을 붙이는 것이기 때문에 상수를 대상으로 참조자를 선언할 수 없다.  
 `int &ref = 20; // 불가능`
 - 미리 참조자를 선언했다가 후에 누군가를 참조하는 것은 불가능하며, 참조의 대상을 변경하는 것 또한 불가능하다.  
 `int &ref; // 불가능`
 - 참조자를 선언하면서 NULL로 초기화하는 것 또한 불가능하다.  
 `int &ref = NULL; // 불가능`
 - 배열 뿐만 아니라 배열의 요소도 변수로 간주되어 참조자의 선언이 가능하다.  
 `int &ref = arr[0]; // 가능`
 - 포인터 변수 또한 변수이기 때문에 참조자 선언이 가능하다.  
 `int *ptr = &num; int *(&pref) = ptr; // 가능`


# 2-4 참조자(Reference)와 함수
 - 참조자의 활용에는 함수가 큰 위치를 차지한다.

## Call-by-Value & Call-by-Reference

### value와 reference
 - call-by-value의 형태로 정의된 함수의 내부에서는 함수외부에 선언된 변수에 접근이 불가능하다.
 - call-by-reference의 형태로 정의된 함수는 함수외부에 선언된 변수에 직접 접근하여 값을 변화시킬 수 있다.

### 주소 값 전달
 - `int *func(int *ptr) { return ptr + 1; }` 함수는 call-by-value함수이다. 이 함수의 연산 주체는 주소의 값이기 때문이다.
 - `int *func(int *ptr) { *ptr = 20; }` 함수는 call-by-reference함수이다. 이 함수는 주소 값을 이용해 함수 외부에 선언된 변수를 참조(reference)했기 때문이다.
 - 본디 c언어에서 말하는 Call-by-reference는 "주소 값을 전달받아서, 함수 외부에 선언된 변수에 접근하는 형태의 함수호출"을 말한다.
 - 따라서 c++에서는 각각 주소 값과 참조자를 이용한 call-by-reference의 함수정의가 가능하다.


## 참조자를 이용한 call-by-reference
 - call-by-reference의 가장 큰 핵심은 함수 내에서 함수외부에 선언된 변수에 접근할 수 있다는 것이다. 이는 참조자를 통해서도 가능하다.
```
void SwapByRef2(int &ref1, int &ref2)
{
	int temp = ref1;
	ref1 = ref2;
	ref2 = temp;
}
```
 - 참조자는 선언과 동시에 변수로 초기화되어야 하지만, 매개변수는 함수가 호출되어야 초기화가 진행되는 변수이다.
 - 따라서 위의 매개변수 선언은 함수호출 시 전달되는 인자로 초기화를 하겠다는 의미의 선언이다.
 - 위의 함수를 호출하게 되면 함수의 매개변수는 입력값의 또 다른 이름이 되어 함수 내에서 값을 직접 변경시킬 수 있게 된다.
 - 주의해야 할 점으로, 매개변수의 인자로는 반드시 참조자가 참조할 수 있는 변수가 있어야 한다.

## 참조자를 이용한 call-by-reference의 단점과 const
 - 참조자를 이용한 call-by-reference함수의 호출형은 call-by-value형과 동일하다.
 - 따라서 c++에서는 함수의 호출형만 보고는 이것이 주소를 참조하는지, 값을 참조하는지를 정확히 판단할 수 없다.
   - 이는 코드의 분석 등에 있어서 시간을 낭비하게 하는 단점이다.
 - 함수 내에서 참조자를 통한 값의 변경을 진행하지 않을 경우, 참조자를 `const`로 선언해서 함수의 원형만 보아도 값이 변경이 이뤄지지 않음을 알 수 있게 해야한다.
   - ex) `void Func(const int &ref) { ... }`

## 반환형이 참조자인 경우
 - 함수의 반환형에도 참조형이 선언될 수 있지만 이는 반환형이 참조형이라는 뜻은 아니다.

### case1. 반환된 값을 참조자에 저장하는 경우
```
int &myfunc(int &ref) { ref++; return ref; }

int num1 = 1;
int &num2 = myfunc(num1);
```
 - 위의 선언은 num1, ref, num2 세 변수가 모두 1을 가리키게 한다. 즉 아래의 선언과 동일하다.
```
int num1 = 1;
int &ref = num1;	// 인자의 전달과정에서 일어난 일
int &num2 = ref;	// 함수의 반환과 반환 값의 저장에서 일어난 일
```
 - 참조형으로 반환된 값을 참조자에 저장하면 참조의 관계가 하나 더 추가된다.
 - 하지만 매개변수로 선언된 참조자 ref는 지역변수의 성질을 갖고 있기 때문에 myfunc이 반환되면 ref는 소멸된다.
 - 참조자 ref는 소멸되지만 변수 자체는 소멸되지 않는다. 결과적으로는 num1과 num2만이 값 1을 가리키게 된다.

### case2. 반환된 값을 인자에 저장하는 경우
```
int &myfunc(int &ref) { ref++; return ref; }

int num1 = 1;
int num2 = myfunc(num1);
```
 - case1에서 num2를 참조형이 아닌 변수로 대신하였다.
```
int num1 = 1;
int &ref = num1;	// 인자의 전달과정에서 일어난 일
int num2 = ref;		// 함수의 반환과 반환 값의 저장에서 일어난 일
```
 - case1과 다르게 num2는 myfunc함수의 반환값을 값으로 갖는 새로운 변수가 된다.
 - 반환형이 참조형인 경우 반한 값을 어떠한 형식으로 저장하느냐에 따라 그 결과에 차이가 있으므로 적절한 선택이 필요하다.

### case3. 참조자를 반환하되, 반환형은 기본자료형인 경우
```
int myfunc(int &ref) { ref++; return ref; }

int num1 = 1;
int num2 = myfunc(num1);
```
 - 실행 결과와 실행과정은 case2와 동일하나 반환형이 기본자료형으로 선언된 함수의 반환값은 반드시 변수에 저장해야 한다. 반환 값은 상수나 다름없기 때문이다.  
`int &num2 = myfunc(num1);	// 컴파일 오류!`

### 잘못된 참조의 반환
```
int &myfunc(int n)
{
	int num = 20;
	num += n;
	return num;
}
```
 - 위의 함수에서는 지역변수 num에 저장된 값을 반환하지 않고 num을 참조의 형태로 반환한다.  
`int &ref = myfunc(10);`
 - 위와 같은 형태로 함수를 호출하면 지역변수 num에 ref라는 또 하나의 이름이 붙게 된다. 하지만 num은 함수가 종료되면 소멸되게 된다.
   - num의 값은 메모리에 그대로 남아있어 결과를 출력하긴 하지만, 메모리가 덮어씌워지면 오류가 발생하게 된다.
 - 지역변수를 참조형으로 반환하는 일은 없어야 한다. 컴파일러도 에러 메세지를 띄워주지 않는다.

## const 참조자

### const 참조자의 특징
 - `const` 선언을 통해 상수화된 변수에 대해서 일반적인 참조자의 생성은 불가능하다.
 - `const int &ref = num;`과 같이 참조자 선언 앞에도 `const`를 추가해 참조자를 이용한 값 변경을 방지해야 한다.

### const를 이용한 상수 참조
`int num = 20 + 30;`
 - 위의 식에서 숫자 20과 30과 같이 프로그램상에 표현되는 숫자를 가리켜 '리터럴(literal)' 또는 리터럴 상수라 한다.
 - 리터럴 상수는 '임시적으로 존재하며 다음 행으로 넘어가면 존재하지 않는 상수'라는 특징을 가진다.
`const int &ref = 30;`
 - `const` 참조자를 이용해서 상수를 참조할 때 c++은 '임시변수'라는 것을 만들어 그 장소에 상수를 저장하고선 참조자가 이를 참조하게끔 한다.
 - 임시로 생성한 변수를 상수화하여 이를 참조자가 참조하게끔 하는 규칙이므로 결과적으론 상수화된 변수를 참조하는 형태가 된다.
   - 이러한 참조를 가능하게 한 것은 정의된 함수에 인자의 전달을 목적으로 변수를 선언하는 번거로운 일을 방지하기 위해서이다.
```
int add(const int &num1, const int &num2) { return num1 + num2; }

cout << add(3, 4) << endl;
```


# new & delete
 - c언어에서 사용하는 동적 할당 방식인 malloc, free는 다음과 같은 단점이 있다.
   - 할당할 대상의 정보를 무조건 바이트 크기단위로 전달해야 한다.
   - 반환형이 void형이기 때문에 적절한 형변환을 거쳐줘야 한다.

## new, delete의 사용 예시
```
int *ptr1 = new int;			// int형 변수 할당
double *ptr2 = new double;		// double형 변수 할당
int *arr1 = new int[3];			// 길이가 3인 int형 배열 할당
double *arr2 = new double[7];	// 길이가 7인 double형 배열 할당

delete ptr1;					// 앞서 할당한 int형 변수 소멸
delete ptr2;					// 앞서 할당한 double형 변수 소멸
delete []arr1;					// 앞서 할당한 int형 배열 소멸
delete []arr1;					// 앞서 할당한 double형 배열 소멸
```

## 객체 생성에서의 new와 delete
 - new와 malloc의 동작 방식에는 차이가 있다. 자세한 것은 클래스, 객체, 생성자를 공부하면서 알게 된다.

## 참조자에서의 new와 delete
 - 참조자의 선언은 상수가 아닌 변수를 대상으로만 가능하다.
 - 변수의 정의에 따르면 변수의 자격을 갖추기 위해서는 메모리 공간이 할당되고, 그 공간을 의미하는 이름이 있어야 한다.
 - c++에서는 new연산자를 이용해 할당된 메모리 공간도 변수로 간주하여 참조자의 선언이 가능하다.


# c++에서 c언어의 표준함수 호출
 - c언어의 라이브러리 내의 표준 함수들은 c++의 표준 라이브러리에도 포함되어 있다.
 - c++내에서 c언어의 함수를 선언하기 위해서는 헤더명에 c를 더하고 .h를 빼면 된다.
```
#include <stdio.h>	-> #include <cstdio>
#include <stdilb.h>	-> #include <cstdlib>
#include <math.h>	-> #include <cmath>
#include <string.h>	-> #include <cstring>
```
 - c의 표준에 정의된 함수들도 std이름공간 안에 선언되어 있기 때문에 `using namespace std`등으로 이름공간을 명시해줘야 한다.
 - `stdio.h`와 같은 c언어 라이브러리를 사용해도 되지만 c++전용 라이브러리는 c++ 문법을 기반으로 개선된 라이브러리를 제공한다.