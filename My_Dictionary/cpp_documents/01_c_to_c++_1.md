# 1-1 c에서 c++로

## A.Hello World!

### 1. 헤더 선언
 - c++의 헤더 또한 c와 마찬가지로 `.h`의 확장자를 갖지만, 표준 라이브러리의 변화로 신버전의 라이브러리는 확장자를 생략하기로 하였다.

### 2. 출력 방법
 - `std::cout`과 `<<` 연산자를 이용해 대상을 출력한다. `<<`연산자를 추가로 사용하여 하나의 `cout`에 여러 종류의 값을 출력할 수 있다.
 - `std::endl`의 출력은 개행으로 이어진다.

## B.기초적인 입력

### 1. 입력 방법
 - `std::cin`과 `>>`연산자를 이용해 대상을 입력받는다. `>>`연산자를 추가로 사용하여 하나의 `cin`에 여러 종류의 값을 입력받을 수 있다.
 - c++에서는 데이터의 입력 또한 데이터의 출력과 마찬가지로 별도의 형식 지정이 필요가 없다. 입력 형식은 지정된 대상 변수의 형식을 따른다.

### 2. 지역변수 선언
 - c++의 지역변수는 함수 내 어디에서든 가능하다. 다만 사용되는 변수는 미리 위에 선언되어 있어야 한다.


# 1-2 함수 오버로딩

## 함수 오버로딩의 이해
 - c언어는 함수를 호출할 때 함수의 이름만을 이용해 호출대상을 찾는다.
 - 하지만 c++은 함수의 이름과 함수의 매개변수를 이용해 호출대상을 찾기 때문에 매개변수의 개수와 종류가 다르면 동일한 이름의 함수 정의를 허용한다. 이를 함수의 오버로딩이라 한다.
 - 함수 오버로딩을 가능케 하려면 매개변수의 자료형 또는 개수가 달라야 하지만, 함수의 반환형만이 다르면 오버로딩이 불가능하다.


# 1-3 매개변수의 디폴트 값

## 매개변수의 디폴트 값 지정
 - c++에서는 함수의 매개변수를 `int myfunc(int num=7)`과 같은 형태로 선언하는 것이 가능하다.
   - 이는 함수 호출시 인자를 전달하지 않으면 선언된 값으로 간주하겠다는 뜻이다.
   - 따라서 두 함수 호출분 `myfunc()`와 `myfunc(7)`은 동일하다.
 - 매개변수의 디폴트 값이 설정되어 있으면 선언된 매개변수의 수보다 적은 수의 인자전달이 가능하다. 그리고 전될되는 인자는 왼쪽에서부터 채워져 나가고, 부족분은 디폴트 값으로 채워진다.
   - `int adder(int num1=1, int num2=2) { return (num1 + num2); }`라는 함수가 있을 때 `adder()`의 값은 3, `adder(5)`의 값은 7, `adder(5, 3)`의 값은 8이 된다.

## 디폴트 값 지정에 유의해야 할 점들
 - 함수의 원형을 헤더 파일 등에 별도로 선언하는 경우 매개변수의 디폴트 값은 함수의 원형 선언에만 위치시켜야 한다.
 - 다수의 매개변수에 대해서 디폴트 값은 일부의 변수에만 지정할 수 있다. 하지만 디폴트 값을 일부만 지정할 때는 반드시 맨 오른쪽의 값부터 지정해야 한다.
   - 함수가 전달되는 인자가 맨 왼쪽에서부터 채워지기 때문이다.
 - `int func(int a=10)`과 `int func(void)`의 함수 오버로딩은 정상적으로 컴파일되나 `func()`호출 시 어떠한 함수를 호출하는지 모호해져 컴파일 에러를 발생시킨다.


# 1-4 인라인(inline)함수

## 매크로 함수
 - c언어에서는 #define 선행처리 지시문에 인수로 함수의 정의를 전달함으로써 함수처럼 동작하는 매크로를 만들 수 있다. 이를 매크로 함수라 한다.
   - ex) `#define SQUARE(x) ((x)*(x))`
   - 위의 예시는 `cout << SQUARE(5);`를 `cout << ((5)*(5));`로, 전처리 과정을 거치면서 코드를 직접 변화시킨다.
   - 매크로 함수는 일반 함수에 비해 실행속도와 성능향상의 이점이 있지만, 함수를 정의하기 어렵고 복잡한 함수의 정의에 한계가 있다.
 - 매크로 수의 장점을 유지하며 일반 함수처럼 정의가 가능하게 한 것이 c++의 인라인 함수이다.

## c++에서의 인라인 함수 정의
 - `inline`키워드를 이용해 인라인 함수를 정의할 수 있다.
   - ex) `inline int SQUARE(int x) { return (x * x); }`
 - 매크로 함수는 전처리기에서 처리하지만, 인라인 함수는 컴파일러에서 처리를 한다. 따라서 컴파일러는 인라인 함수가 성능에 해가 될 것이라 판단하면 키워드를 무시하기도 한다.

## 인라인 함수의 장단점
 - 인라인 함수는 컴파일러가 해당 함수의 코드 전체를 선언 위치로 복사하여 대체하기 때문에 호출 단계가 줄어 성능이 향상된다.
 - 인라인 함수를 많이 사용하면 컴파일 이후 실행 파일의 크기가 커지게 된다. 또한 함수 정의부가 길면 인라인 함수의 이점도 줄어든다.

## 인라인 함수의 특징
 - 인라인 함수는 코드 대체를 위해 함수의 선언과 정의가 한 파일 내에 존재해야 한다.
 - 컴파일러의 최적화 방법에 따라서 컴파일러가 일반 함수를 인라인 함수로 취급하여, 실행 파일을 만들 수 있다. 거꾸로 컴파일러가 inline 함수를 일반 함수로 취급하여 실행 파일을 만들 수 있다. 
 - 인라인 함수는 함수 선언과 정의가 한곳에 있고 함수 호출문이 모두 함수 정의로 대체된다고 하니, 코드를 읽을 때 시선을 여기저기 옮기지 않아도 돼서 가독성이 좋을 것으로 생각 할 수 있지만 호출문이 정의로 대체되는 시점은 컴파일 이후이다. 

## 인라인 함수와 템플릿
 - 매크로 함수는 자료형에 의존적이지 않지만 인라인 함수는 자료형에 의존적이다.
 - 함수의 오버로딩을 이용해 해결할 수 있지만, 한 번만 정의하면 되는 매크로 함수의 장점을 더욱 희석시키게 된다.
 - 이는 템플릿이라는 기능을 활용하여 해결할 수 있다. 템플릿은 ch.13, ch.14에서 학습힌다.


# 1-5 이름공간(namespace)
 - 이름공간은 말 그대로 이름을 붙여놓은 공간, 즉 특정 영역에 이름을 붙여주기 위한 문법적 요소이다.
 - 프로그램이 대형화되며 여러 모듈에서 가져오는 함수들의 이름이 충돌하는 문제가 생겼다. 이를 해결하기 위해 정의된 문법이다.

## 이름공간의 기본 원리
 - 한 집에 동일한 이름의 사람이 두 명이 살면 호출에 문제가 생길 수 있지만, 다른 집에 동일한 이름의 사람이 살면 문제될 것이 없다.
 - 동일한 이름과 매개변수를 가진 두 함수를 한 프로그램 안에 넣으면 문제가 생기지만, `namespace`를 이용해 이름공간을 만들면 해결된다.
```
namespace Temp1
{
	void	function(void)
	{
		std::cout << "test namespace" << std::endl;
	}
}
```
 - `::`연산자를 범위지정 연산자라고 하며 이름공간을 지정할 때 사용된다.

## 이름공간 기반 함수 선언과 정의의 구분
 - 함수의 선언은 헤더 파일에, 함수의 정의는 소스 파일에 저장하는 것이 보통이다.
 - 이름공간 기반 함수의 선언은 다음과 같다.  
 `namespace Temp1 { void function(void); }`
 - 이름공간 기반 함수의 정의는 다음과 같다.  
`void Temp1::function(void) {...}`
 - 동일한 이름공간 안에 정의된 함수를 호출할 때는 범위지정 연산자를 이용한 이름공간 명시를 할 필요가 없다.

## 이름공간의 중첩
 - 이름공간은 다른 이름공간 안에 삽입될 수 있다.  
`namespace Parent { namespace Sub { int num = 1; } }`
 - 중첩된 이름공간 내의 함수 역시 범위지정 연산자를 사용해 꺼내 쓸 수 있다.  
`std::cout << Parent::Sub::num;`

## using을 이용한 이름공간의 명시
 - `using`을 이용해 이름공간과 범위지정 연산자를 생략할 수 있다.
 - 다음 선언은 `Hybfunc`를 `Hybrid`이름공간에서 찾으라는 일종의 선언이다.  
`using Hybrid::HybFunc;`
   - `HybFunc`는 함수의 이름 또는 변수의 이름이 될 수 있다.
   - `using`의 선언이 함수 내에 존재하면 지역변수의 선언과 동일한 사이클을 갖는다. 따라서 프로그램의 전체 영역에 효력을 미치게 하려면 전역변수와 마찬가지로 함수 밖에다 선언해야 한다.
 - `using namespace`를 이용해 특정 이름공간 내에 선언된 모든 것에 대한 이름공간 지정의 생략을 명할 수 있다.
   - ex) `using namespace std;`는 `std`이름공간에 대한 모든 지정을 생략하라는 뜻이다.
   - `using namespace`의 사용은 프로그래밍의 편의성을 가져다주지만, 이름충돌의 발생확률이 증가하게 된다.

## 이름공간의 별칭 지정
 - 과도한 이름공간의 중첩 또한 `namespace`을 이용해 별칭을 줄 수 있다.  
`namespace ABC=AAA:BBB:CCC;`

## 범위지정 연산자의 또 다른 기능
 - 지역변수의 이름이 전역변수의 이름과 같을 경우, 전역변수는 지역변수에 의해 가려진다는 특징이 있다.
 - 같은 이름을 가진 지역변수가 있는 함수 내에서 전역변수에 접근할 때 범위지정 연산자를 사용하게 된다.
```
int val = 100;				//전역 변수

int SimpleFunc(void)
{
	int val = 20;			//지역 변수
	val += 3;				// 지역변수 val의 값 3 증가
	::val += 7;				// 전역변수 val의 값 7 증가
}