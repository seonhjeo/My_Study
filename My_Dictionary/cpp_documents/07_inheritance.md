# 7-1 들어가기에 앞서
 - 상속은 두 챕터에 걸쳐 다음과 같이 설명한다.
   - 1단계 : 문제의 제시
   - 2단계 : 기본개념 소개
   - 3단계 : 문제의 해결

## 상속에 대한 새로운 관점의 이해
 - 과거에는 '기존에 정의해 놓은 클래스의 재활용을 목적으로 만들어진 문법적 요소가 상속이다.'라는 생각이 강했지만, 시대가 바뀌며 상속에 대한 새로운 관점이 많이 생겼다.
 - c++의 상속은 물려받는 이미지가 강해 과거에는 위와 같은 생각으로 상속을 바라봤다.

## 문제의 제시
 - 다음과 같은 클래스들이 있다.
```
class PermanentWorker
{
private:
    char name[100];
    int salary;
public:
    PermanentWorker(char *name, int money)
        : salary(money) { ... }
    int GetPay() const { return salary; }
    void ShowSalaryInfo() const { ... }
}
```
```
class EmployeeHandler
{
private:
    PermanentWorker *empList[50];
    int empNum;
public:
    EmployeeHander() : empnum(0) { }
    void AddEmployee(PermanentWorker *emp) { ... }
    void ShowAllSalaryInfo() const { ... }
    void ShowTotalSalary() const { ... }
    ~EmployeeHandler() { ... }
}
```
 - 위의 PermanentWorker 클래스는 데이터적 성격이 강한 반면 EmployeeHandler 클래스는 기능적 성격이 강하다.
   - **기능적 처리를 실재로 담당하는 클래스를 가리켜 '컨트롤 클래스' 혹은 '핸들러 클래스'라 한다.**
 - 위와 같은 상황에서 데이터 클래스의 종류가 새로 추가되야 한다면 컨트롤 클래스에는 대대적인 수정작업이 필요하다.
   - 이는 확장성이 좋다고 말할 수 없다.
   - 위와 같은 상황을 해결하기에 상속이 적절하다.


# 7-2 상속의 문법적인 이해

## 상속이란?
 - Student클래스가 Person클래스를 상속한다.
   - Student클래스가 Person클래스를 상속하게 되면, Student클래스는 Person클래스가 지니고 있는 모든 멤버를 물려받는다.
   - 즉 Student객체에는 Student클래스에 선언되어 있는 멤버뿐만 아니라 Person클래스에 선언되어 있는 멤버도 존재하게 된다.

## 클래스 상속간 용어의 정리
 - 상속의 대상이 되는 클래스를 상위 클래스, 기초 클래스, 슈퍼 클래스, 부모 클래스라 지칭한다.
 - 상속받은 클래스를 하위 클래스, 유도 클래스, 서브 클래스, 자식 클래스라 지칭한다.
 - 해당 글에서는 상속 대상 클래스를 기초 클래스, 상속받은 클래스를 유도 클래스라 칭한다.

## 상속의 방법과 결과
 - 상속은 다음과 같이 할 수 있다.  
`class Student : public Person { ... } // Person클래스를 상속받는 Student클래스`
   - 유도 클래스는 상속의 대상이 되는 클래스의 멤버까지도 객체 내에 포함이 된다.
   - 따라서 유도 클래스는 기초 클래스의 멤버함수를 호출할 수 있다.

## 유도 클래스의 생성자 정의
 - 유도 클래스의 생성자는 다음과 같이 작성할 수 있다.
```
Student(char *name, int age, char *major)
    : Persen(age, name) { ... }     // 이니셜라이저를 이용한 기초 클래스 Person의 초기화
```
 - Student클래스의 생성자는 Person클래스의 멤버까지 초기화해야 할 의무가 있다.
 - Student클래스의 생성자는 Person클래스의 생성자를 호출해서 Person클래스의 멤버를 초기화하는 것이 좋다.
 - 유도 클래스는 이니셜라이저를 이용해 기초 클래스의 생성자 호출을 명시할 수 있다.

## 상속에서의 접근제한
 - 접근제한의 기준은 클래스이다. 클래스 외부에서는 private 멤버에 접근이 불가능하다.
 - 유도 클래스의 멤버함수는 기초 클래스의 private 멤버변수에 직접 접근이 불가능하다. 따라서 public에 선언된 접근함수를 이용해 접근해야 한다.
 - 정보의 은닉은 하나의 객체 내에서도 진행이 된다.

## 유도 클래스의 객체 생성과정
 - 유도 클래스 객체 생성과정은 다음과 같은 규칙을 가진다.
   - 유도 클래스의 객체생성 과정에서 기초 클래스의 생성자는 항상 호출된다.
   - 유도 클래스의 생성자에서 기초 클래스의 생성자 호출을 명시하지 않으면 기초 클래스의 void형 생성자가 호출된다.
   - 기본 생성자(void)형 생성자가 기초 클래스에 선언되어 있지 않으면 컴파일 오류가 발생한다.
 - 유도 클래스의 객체 생성 과정에서 메모리 할당
   - 객체 생성문에 아무런 값이 전달되지 않으면 자동으로 void형 생성문을 호출하게 된다.
   - 유도 클래스의 생성자에 대한 메모리 할당이 먼저 일어난다. 이 때 호출이 완성되지 않았으므로 객체라 부를 수 없다.
   - 유도 클래스의 객체 생성문에 의해 값이 전달되며 생성자가 호출된다.
   - 유도 클래스의 생성자를 호출한 후에, 상속하고 있는 기초 클래스의 생성자 호출을 위해 기초 클래스의 이니셜라이저를 확인한다.
   - 적절한 이니셜라이저를 이용해 기초 클래스의 생성자를 호출해 기초 클래스의 멤버변수를 초기화한다.
   - 유도 클래스의 생성자 실행을 마무리하며 유도 클래스의 멤버변수를 초기화한다.
 - **'클래스의 멤버는 해당 클래스의 생성자를 통해 초기화된다'는 기본 원칙은 유도 클래스의 객체 생성과정에서도 지켜지고 있다.**

## 유도 클래스 객체의 소멸과정
 - 유도 클래스의 객체가 소멸될 때는 유도 클래스의 소멸자가 실행된 이후에 기초 클래스의 소멸자가 실행된다.
   - 스택에 생성된 객체의 소멸순서는 생성순서와 반대이다.
 - 생성자에서 동적 할당한 메모리 공간은 소멸자에서 해제한다.


# 7-3 protected 선언과 세 가지 형태의 상속

## protected로 선언된 멤버가 허용하는 접근의 범위
 - protected로 선언된 멤버변수는 이를 상속하는 유도 클래스에서 접근이 가능하다.
   - 하지만 기본적으로는 기초 클래스와 이를 상속하는 유도 클래스 사이에서도 정보은닉은 지켜지는 것이 좋다.

## 세 가지 형태의 상속
 - 상속에는 상속의 형태에 따라 public, protected, private 상속의 형태가 있다.
 - 형때에 따른 상속의 선언은 다음과 같다.
```
class Derived : public Base { ... }     // public 상속
class Derived : protected Base { ... }  // protected 상속
class Derived : private Base { ... }    // private 상속
```
 - 상속 형태에 따른 상속에 대한 의미는 다음과 같다.
   - 상속 형태보다 접근의 범위가 넓은 멤버는 상속 형태로 변경시켜 상속하겠다.
   - 예를 들어 private 상속시 기초 클래스의 protected와 public멤버들을 private형태로 변경시켜 상속한다.
 - c++에서는 거의 대부분의 경우 public상속만을 시킨다.


# 7-4 상속을 위한 조건

## 상속을 위한 기본 조건 IS-A
 - 유도 클래스는 기초 클래스의 모든 특성을 가지고 추가로 자신만의 특성을 가진다.
 - '일종의 ~이다.' 라는 문장에 부합하는 관계를 뜻한다.
   - 휴대폰은 일종의 전화기이다.
   - 전기차는 일종의 자동차이다.

## HAS-A 관계와 복합 관계
 - 유도 클래스는 기초 클래스가 지니고 있는 모든 것을 소유한다.
 - '~을 소유한다.'라는 문장에 부합하는 관계를 뜻한다.
   - 경찰은 총을 소유한다.
   - 프로그래머는 컴퓨터를 소유한다.
 - 하지만 위의 상황에서는 상속보다 클래스 내에 멤버로써 선언하는 등의 복합 관계를 맺는 것이 더 효율적이다.
 - 경우에 따라 상속관계를 사용할 수 있으나 프로그램 변경에 많은 제약을 가져다준다.