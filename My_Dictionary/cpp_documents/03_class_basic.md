# 3-1 c++에서의 구조체

## 구조체의 등장 배경
 - 구조체는 연관 있는 데이터를 묶을 수 있는 문법적 장치이다.
   - 소프트웨어 = 데이터의 표현 + 데이터의 처리.
   - 표현해야 하는 데이터는 항상 부류를 형성하기 마련이다.
   - 연관이 있는 데이터들을 하나로 묶으면 프로그램의 구현 및 관리가 용이하다.

## c++에서 구조체 변수의 선언
 - c언어에서 구조체 변수를 선언하는 방법은 다음과 같다.  
`struct Car basicCar;`
   - 키워드 `struct`는 이어서 선언되는 자료형이 구조체를 기반으로 정의된 자료형임을 나타낸다.
   - c++에서는 기본 자료형 변수의 선언방식이나 구조체 기반 자료형 변수의 선언방식에 차이가 없다. 따라서 다음과 같이도 선언할 수 있다.  
   `Car basicCar;`
 - 다음은 구조체 변수의 정의와 선언이다.
 ```
struct Car						// 구조체 변수 정의
{
	char gamerID[20];
	int fuelGauge;
	int curSpeed;
}

Car run99 = {"run99", 100, 0};	// 구조체 변수 선언 및 값 초기화	
 ```

## 구조체 안에 함수 삽입
 - 구조체의 데이터만을 처리하는 함수는 구조체에 종속적이다. 이러한 함수들을 전역함수로 선언하면, 다른 영역에서 해당 함수를 호출하는 실수를 범할 수도 있다.
 - 구조체 안에 구조체에 종속적인 함수들을 묶어버리면 보다 확실한 구분이 가능해진다. 그리고 c++에서는 구조체 안에 함수를 삽입하는 것을 허용한다.
 ```
struct Car
{
	char gamerID[20];
	int fuelGauge;
	int curSpeed;

	void ShowCarState() { ... }
	void Accel() { ... }
	void Break() { ... }
}

Car run99 = {"run99", 100, 0};
run99.Accel();
run99.Break();

Car speed77 = {"speed77", 100, 0};
speed77.Accel();
speed77.ShowCarState();
```
 - 구조체 밖에 존재하는 함수들은 매개변수를 통해 데이터를 전달받고, 참조자 혹은 반환자를 통해 연산 혹은 출력을 진행한다.
 - 반면 구조체 안에 삽입된 함수는 구조체 안의 변수에 직접적으로 접근이 가능해졌기 때문에 연산의 대상에 대한 정보가 불필요하다.
 - 실제로는 모든 동일한 구조체들이 하나의 함수를 공유하지만, 논리적으로 각각의 구조체 변수가 자신의 함수를 별도로 갖는 것과 같은 효과를 보인다.
 - 구조체 변수를 선언할 때 초기화의 대상은 함수가 아닌 변수이므로, 함수가 삽입되었어도 구조체의 초기화 방법은 변하지 않는다.
 - 구조체 내에 함수를 정의하였으면, 위의 예시처럼 구조체 변수를 대상으로 함수의 호출이 이루어져야 한다.

## 구조체 안에 enum 상수 선언
 - c언어에서 상수를 선언할 때에는 `#define NUM 1`과 같은 매크로 상수를 주로 사용하였다.
 - 이러한 상수들 역시 함수처럼 구조체 안에서만 의미가 있는 상수일 경우 열거형 `enum`을 사용해 구조체 안에 상수를 추가할 수 있다.
```
struct Car
{
	enum
	{
		ID_LEN		= 20;
		MAX_SPD		= 200;
		FUEL_STEP	= 2;
	}

	char gamerID[ID_LEN];
	int fuelGauge;
	int curSpeed;

	void ShowCarState() { ... }
	void Accel() { ... }
	void Break() { ... }
}
```
 - `enum`열거형을 구조체 안에서 사용하는 것이 부담스러우면 이름공간을 이용해 상수가 사용되는 영역을 명시하는 것도 또 다른 방법이 될 수 있다.
 - 이름공간을 이용하면 몇몇 구조체들 사이에서만 사용하는 상수들을 선언할 때 특히 도움이 된다.
 - `enum`열거형을 사용할 때보다 가독성도 좋아지는 경향이 있다. 이름공간을 지정했기 때문에 이 상수가 어느 영역에서 선언되고 사용되는지 알기 쉽기 때문이다.
```
namespace CAR_CONST
{
	enum
	{
		ID_LEN		= 20;
		MAX_SPD		= 200;
		FUEL_STEP	= 2;
	}
}

struct Car
{
	char gamerID[CAR_CONST::ID_LEN];
	int fuelGauge;
	int curSpeed;

	void ShowCarState() { ... }
	void Accel() { ... }
	void Break() { ... }
}
```

## 구조체 함수를 외부로 빼기
 - 보통 프로그램을 분석할 때, 흐름 및 골격 위주로 분석하는 경우가 많다. 이러한 경우에는 대부분 함수의 기능만 파악하지, 함수의 세부구현은 잘 신경쓰지 않는다.
 - 따라서 구조체 내의 함수들에 대한 가독성을 높이기 위해, 다음과 같이 구조체 밖으로 함수를 빼낼 필요가 있다.
```
struct Car
{
	char gamerID[CAR_CONST::ID_LEN];
	int fuelGauge;
	int curSpeed;

	void ShowCarState();
	void Accel();
	void Break();
}

void Car::ShowCarState() { ... }
void Car::Accel() { ... }
void Car::Break() { ... }
```
 - 이처럼 함수의 원형선언을 구조체 안에 두고, 함수의 정의를 구조체 밖으로 뺄 수 있다. 다만 빼낸 다음에 해당 함수가 어디에 정의되어 있는지에 대한 정보만 추가해주면 된다.
 - 구조체 안에 함수가 정의되어 있으면 함수를 인라인으로 처리하라는 의미이지만, 함수를 구조체 밖으로 빼내면 이러한 의미가 사라진다.
 - 따라서 인라인의 의미를 그대로 유지하려면 다음과 같이 키워드 `inline`을 이용해 인라인 처리를 명시적으로 지시해야 한다.
```
inline void Car::ShowCarState() { ... }
inline void Car::Accel() { ... }
inline void Car::Break() { ... }
```


# 3-2 클래스(Class)와 객체(Object)

## 클래스와 구조체의 차이점
 - 키워드 `struct`을 대신해서 `class`를 사용하면 구조체가 아닌 클래스가 된다.
```
class Car
{
	char gamerID[20];
	int fuelGauge;
	int curSpeed;

	void ShowCarState() { ... }
	void Accel() { ... }
	void Break() { ... }
}
```
 - 하지만 `class`는 `struct`와 다르게 다음의 방식으로 구조체 변수의 선언이 불가능하다.  
```
Car run99 = {"run99", 100, 0};	//에러
run99.fuelGauge = 100;			//에러
strcpy(run99.gamerID, "run99")	//에러
```
 - 클래스 내에 선언된 변수는 기본적으로 클래스 내에 선언된 함수에서만 접근이 가능하다.
   - 따라서 클래스는 정의를 하는 과정에서 각각의 변수 및 함수의 접근 허용범위와 접근과 관련된 지시를 별도로 선언해야 한다.

## 접근제어 지시자
 - c++에서의 접근 제어 지시자는 함수를 구조체 내에 정의하거나, 구조체 키워드가 생략되는 것 이외에도 멤버의 접근에 제한을 둘 수 있도록 하는 것이다.
 - c++의 접근 제어 지시자는 다음과 같이 총 3가지가 존재한다.
   - `public	// 프로그램 어디에서든 접근 허용`
   - `protected	// 상속관계에 놓여있을 때 유도 클래스에서만 접근 허용`
   - `private	// 클래스 내(클래스 내에 정의된 함수)에서만 접근 허용`

### 접근 제어 지시 예시문
```
class Car
{
private :	// 같은 클래스 내에서만 접근 가능
	char gamerID[ID_LEN];
	int fuelGauge;
	int curSpeed;
public:		// 프로그램 어디서든 접근가능
	void InitMembers(char *ID, int fuel);
	void ShowCarState();
}
```
 - 클래스 내에서 `private`으로 선언된 변수의 초기화를 목적으로 `InitMembers`함수를 정의하였다.
   - `InitMembers`함수는 동일 클래스 내에 있어 `private`으로 선언된 변수에 접근이 가능하고, public으로 선언되었으므로 어디에서든 선언이 가능하다.
 - 위의 예시와 지금까지 배운 내용을 토대로 다음 사실들을 알 수 있다.
   - 접근 제어 지시자 A가 선언되면 그 이후 등장하는 변수나 함수는 A에 해당하는 범위 내에서 접근이 가능하다.
   - 새로운 접근 제어 지시자 B가 선언되면, 그 이후로 등장하는 변수나 함수는 B에 해당하는 범위 내에서 접근이 가능하다.
   - 함수의 정의를 클래스 밖으로 빼도, 이는 클래스의 일부이기 떄문에 함수 내에서는 `private`으로 선언된 변수에 접근이 가능하다.
   - 키워드 `struct`를 이용해 정의한 구조체에 선언된 변수와 함수에 별도의 접근제어 지시자를 선언하지 않으면, 모든 변수와 함수는 `public`으로 선언된다.
   - 키워드 `class`를 이용해 정의한 클래스에 선언된 변수와 함수에 별도의 접근제어 지시자를 선언하지 않으면, 모든 변수와 함수는 `private`으로 선언된다.
 - `struct`와 `class`의 유일한 차이점은 별도의 접근제어 지시자를 선언하지 않았을 때의 차이밖에 없다.
 - 접근 제어 지시자의 뒤에는 `;`이 아닌 `:`이 붙는데 이는 접근제어 지시자가 특정 위치정보를 알리는 '레이블'이기 때문이다.

## 객체(Object), 멤버변수, 멤버함수
 - 선언된 클래스는 변수라는 표현 대신 '객체'라는 표현을 사용한다.
   - 클래스를 구성하는(클래스 내에 선언된) 변수를 가리켜 '멤버변수'라 하고, 클래스를 구성하는(클래스 내에 정의된) 함수를 가리켜 '멤버함수'라 한다.
```
class Car	// 클래스
{
private :
	char gamerID[ID_LEN];	// 멤버변수
	int fuelGauge;			// 멤버변수
	int curSpeed;			// 멤버변수
public:
	void InitMembers(char *ID, int fuel);	// 멤버함수
	void ShowCarState();					// 멤버함수
}

int main(void)
{
	Car myCar;	// 클래스 객체 선언
	...
}
```

## c++에서의 파일분할

### 들어가기 전에...
 - 헤더 파일이란?
   - C 언어 및 C++에서 사용하는 일종의 레퍼런스. 주로 외부 소스 파일에 정의된 변수나 함수를 쓰기 위해 만들어졌다.
   - 크게 컴파일러가 기본적으로 지원하는 표준 헤더와 사용자가 임의로 만든 사용자 헤더로 나눠진다.
 - 링커란?
   - 링커(linker) 또는 링크 에디터(link editor)는 컴퓨터 과학에서 컴파일러가 만들어낸 하나 이상의 목적 파일을 가져와 이를 단일 실행 프로그램으로 병합하는 프로그램이다.

### 클래스의 파일 분할
 - 대체적으로 헤더 파일`(ex)Car.h)`에는 클래스의 선언을, 소스 파일`(ex)car.cpp)`에는 클래스의 정의(멤버함수의 정의)를 담는다.
 - '클래스의 선언(declaration)'은 다음과 같다.
```
class Car
{
private :
	char gamerID[ID_LEN];
	int fuelGauge;
	int curSpeed;
public:
	void InitMembers(char *ID, int fuel);
	void ShowCarState();				
}
```
   - '클래스의 선언'은 컴파일러가 클래스와 관련된 문장의 오류를 잡아내는 데 필요한 최소한의 정보로써, 클래스를 구성하는 외형적인 틀을 보여준다.
 - '클래스의 정의'는 다음과 같다.
```
void InitMembers(char *ID, int fuel) { ... }
void ShowCarState() { ... }
```
   - '클래스의 정의(definition)'에 해당하는 다음 함수의 정의는 다른 문장의 컴파일에 필요한 정보를 가지고 있지 않다.
   - 따라서 함수의 정의는 컴파일 된 이후에, 링커에 듸해 하나의 실행파일로 묶이기만 하면 된다.
 - 인라인 함수는 코드 대체를 위해 함수의 정의 부분도 헤더 파일 안에 작성되어야 한다.


# 3-3 객체지향 프로그래밍의 이해
 - 구조체를 확장한 것이 클래스라고 인식하는 것 자체는 문제가 되지 않으나, 그것이 전부라고 인식하는 것은 문제가 있다.
 - 아래에서는 "나는 과일장수에게 2천원을 주고 두 개의 사과를 구매했다"는 행동을 실체화시키면서 설명한다.

## 객체지향 프로그래밍의 이해
 - c++에서 말하는 객체(Object)는 '사물 또는 대상'을 뜻한다.
 - 즉 객체지향 프로그래밍은 **현실에 존재하는 사물과 대상, 그리고 그에 따른 행동을 있는 그대로 실체화시키는 형태의 프로그래밍**이다.

## 객체를 이루는 것은 데이터와 기능
 - 객체는 하나 이상의 상태 정보(데이터)와 하나 이상의 행동(기능)으로 구성이 된다.
 - 상태 정보는 변수를 통해, 행동은 함수를 통해 표현이 가능하다.

### 과일장수의 객체화
 - 프로그램의 입장에서 바라보는 객체 '과일장수'는 다음과 같다.
   - 과일장수는 과일을 판다.
   - 과일장수는 사과 20개, 오렌지 10개를 보유하고 있다.
   - 과일장수의 과일판매 수익은 현재까지 50,000원이다.
 - 이 중에서 보유하고 있는 사과의 수와 판매 수익을 변수로, 과일을 판매하는 행위를 함수로 하는 과일장수 객체를 만들 수 있다.
 - 과일 가격은 일정하므로 과일 가격 변수는 상수화를 시킬 수 있다. 이는 추후에 배우는 생성자를 이용하여 처리한다.

### 나의 객체화
 - 프로그램의 입장에서 바라보는 객체 '나'는 다음과 같다.
   - 나는 과일을 산다.
   - 나는 현재 현금을 소유하고 있다.
   - 산 과일은 나의 것이 된다.
 - 이 중에서 보유한 현금과 갖고 있는 과일의 개수를 변수로, 과일을 구매하는 행위를 함수로 하는 나 객체를 만들 수 있다.

## 클래스 기반의 객체생성 방법
```
Classname objName;					//일반적인 변수 선언방법
Classname *ptrObj = new Classname;	//동적 할당방식
```

## 객체간의 대화 방법(Message Passing 방법)
 - 다음은 예제 코드의 일부이다.
```
void BuyApples(FruitSeller &seller, int money)
{
	numOfApples += seller.SaleApples(money);
	myMoney -= money;
}

buyer.BuyApples(seller, 2000);
```
   - 위의 함수는 과일장수를 대상으로 과일의 구매를 목적으로 과일장수 객체 내의 SalesApples함수를 호출하는 것이다.
   - 아래의 선언은 사과를 구매하기 위해 구매대상(seller) 객체와 구매금액 변수를 인자로 전달해주는 것이다.
 - 위와 같이 하나의 객체가 다른 하나의 객체에게 어떠한 행위의 요구를 위한 메세지를 전달하는 방법은 함수호출을 기반으로 한다. 이를 메시지 전달(Message Passing)이라 한다.

### 여담
 - 클래스는 아무런 접근제어 지시자의 선언이 없을 때 멤버들을 `private`으로 간주한다.
 - 과일 가격은 일정하므로 과일 가격 변수는 상수화를 시킬 수 있다. 이는 추후에 배우는 생성자를 이용하여 처리한다.