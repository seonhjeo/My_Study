# 4-1 정보은닉(Information Hiding)
 - 좋은 클래스가 되귀 위한 최소한의 조건으로는 '정보은닉'과 '캡슐화'가 있다.

## 정보은닉의 이해
 - 선언하는 대부분의 변수들은 개발자들이 지정한 조건이 있다. (ex: 0 < x...)
 - 하지만 클래스의 멤버변수를 `public`으로 선언해 이러한 조건을 제한하지 않고 직접 변수에 값을 입력할수 있게 되면 문제가 생긴다.
   - 개발자가 지정한 조건이므로 컴파일러가 오류를 출력하지도 않는다.
 - 떄문에 **제한된 방법으로의 접근만 허용을 해서 잘못된 값이 저장되지 않도록 도와야 하고, 또 실수를 했을 때 실수가 쉽게 발견되도록 해야한다.**
 - 멤버변수를 `private`으로 선언하고 해당 변수에 접근하는 함수를 별도로 정의해서, 안전한 형태로 멤버변수의 접근을 유도하는 것이 바로 정보은닉이며, 이는 좋은 클래스가 되기 위한 기본조건이 된다.

### 엑세스 함수(Access Function)
 - 다음 함수들은 엑세스 함수들이다.
```
int GetX() const;           // 변수의 값을 가져옴
bool SetX(int xPos);        // 변수에 조건에 맞게 값을 저장함
```
   - 엑세스 함수는 멤버변수를 `private`으로 선언하면서 클래스 외부에서의 멤버변수 접근을 목적으로 정의되는 함수들이다.
   - 이들은 정의되었으되 호줄되지 않는 경우도 있지만 추후에 필요할 수 있다고 판단되기 때문에 정의한다.

### const함수
 - 위에서 선언한 엑세스 함수중에 이런 함수가 있었다.  
 `int GetX() const;`
   - 이는 **'GetX() 함수 내에서는 멤버변수에 저장된 값을 변경하지 않겠다.'** 라는 뜻이다.
 - 또한 const 함수에는 다음과 같은 특징이 있다.
 ```
int GetNum() { return num; }
void ShowNum() const { cout << GetNum() << endl; } // 컴파일 에러
 ```
   - **const 함수 내에서는 const가 아닌 함수의 호출이 제한된다.** 이는 const로 선언되지 않은 함수는 멤버변수를 변경할 수 있는 능력이 있기 때문에 실제로 변경하지 않더라도 사전에 차단하는 것이다.
   - 이를 고치는 방법은 `GetNum()`함수도 const함수로 변환하는 방법이 있다.
 ```
int GetNum() const { return num; }
void ShowNum() const { cout << GetNum() << endl; }
 ```


# 4-2 캡슐화(Encapsulation)

## 캡슐화가 필요한 이유
 - 감기의 증상에 재채기, 콧물, 코막힘이 있다. 만일 약들이 세 가지의 증상중 하나씩만 치료할 수 있다면 환자는 증상에 맞는 약을 하나씩 먹어야 하는 불편함이 생긴다.
   - 이 때 약의 순서나 제한 조건이 걸린다면 약을 먹을 때 생기는 불편함은 매우 커진다.
 - 이러한 불편함을 해결하기 위해 **관련있는 데이터와 코드를 한 울타리 안에 모아** 코드를 작성하는 것을 캡슐화라고 한다.
   - 세 가지 증상을 동시에 해결해주는 약 하나를 먹게 되는 것과 같은 이치이다.

## 캡슐화의 특징
 - **캡슐화는 범위를 결정하는 일이 쉽지 않기 때문에 캡슐화는 어려운 개념이다.**
   - 위의 예시에서 감기의 증상에 몸살과 목감기 등이 생기면, 위의 약은 캡슐화가 잘 되지 않은 것이라고 할 수 있다. 치료를 위한 새 클래스를 또 선언해야 하기 때문이다.
   - 캡슐화 능력은 오랜 시간을 두고 다양한 사례를 접하며 길러져야 한다.


# 4-3 생성자(Constructor)와 소멸자(Desturctor)
 - 지금까지는 객체를 생성하고 객체의 멤버함수 초기화를 목적으로 한 함수를 정의하였지만, 이는 꽤 불편하다. 생성자를 이용해 이러한 불편함을 줄일 수 있다.

## 생성자의 이해

### 생성자
```
class SimpleClass
{
private:
  int num;
public:
  SimpleClass(int n) { num = n; } // 생성자(constructor)
  int GetNum() const { return num; }
}
```
 - **생성자는 다음의 특징을 갖는다.**
   - 클래스의 이름과 함수의 이름이 동일하다.
   - 반환형이 선언되어 있지 않으며, 실제로 반환하지 않는다.
   - 객체 생성시 단 한번만 호출된다.
 - 생성자는 다음과 같이 호출된다.
```
SimpleClass sc(20);		//생성자에 20 전달
SimpleClass *ptr = new Simpleclass(30);		// 생성자에 30 전달
```
 - **생성자 또한 함수의 일종이기 때문에 다음과 같은 특징을 갖는다.**
   - 오버로딩이 가능하다.
   - 매개변수에 디폴트 값을 설정할 수 있다.
```
SimpleClass() { num1 = 0; num2 = 0;} // 디폴트 값 설정
SimpleClass(int n) { num1 = n; num2 = 0; } // 오버로딩
SimpleClass(int n1, int n2) { num1 = n1; num2 = n2; } // 오버로딩
```
   - `SimpleClass(int n1 = 0, int n2 = 0)`과 같이 디폴트 값을 선언 부분에서 설정하는 것은 생성자 호출의 모호함을 불러오기 때문에 하면 안된다.
 - 입력값이 없는 생성자를 선언할 때 다음과 같은 형식은 구성이 불가능하다.  
```
SimpleClass sc();		// 불가능
SimpleClass sc;			// 가능
SimpleClass *ptr = new Simpleclass();		// 가능
SimpleClass *ptr = new Simpleclass;			// 가능
```	
   - 불가능한 형식에 대해서, 클래스 내에 동일한 이름을 가진 함수 sc()가 있을 경우, 해당 선언이 생성자에 대한 선언인지 아니면 함수에 대한 선언인지 모호하기 때문이다.

## 멤버 이니셜라이저(Member Initializer)
 - 객체 안에 객체가 있는 등의 경우에, 외부 객체를 생성하는 과정에서 내부 객체의 생성자를 통해 내부 객체도 초기화할 수 있다. 이 때 멤버 이니셜라이저를 사용한다.

### 이니셜라이저를 이용한 멤버의 초기화
```
class Rectangle
{
private:
	Point upLeft;
	Point lowRight;
public:
	Rectangle(const int &x1, const int &y1, const int &x2, const int &y2)
		:upLeft(x1, y1), lowRight(x2, y2) { (empty) }		//멤버 이니셜라이저를 이용한 멤버 초기화
}
```
 - 위의 예시에서는 Rectangle의 생성자 뒤에 `:upLeft(x1, y1), lowRight(x2, y2)`이 추가되어 있다. 이것이 의미하는 바는 각각 다음과 같다.
   - 객체 upLeft의 생성과정에서 x1과 y1을 인자로 전달받는 생성자를 호출해라.
   - 객체 lowRight의 생성과정에서 x2와 y2를 인자로 전달받는 생성자를 호출해라.
   - 멤버 이니셜라이저를 사용하다 보면 생성자의 몸체 부분이 비는 일이 종종 발생하니, 이상하게 여길 필요는 없다.

### 객체의 생성 과정
 - 객체의 생성과정을 다음과 같이 정리할 수 있다.
   - 1단계 : 메모리 공간 할당
   - 2단계 : 이니셜라이저를 이용한 멤버변수(객체)의 초기화
   - 3단계 : 생성자의 몸체부분 실행
 - 이니셜라이저가 선언되지 않았으면 메모리 공간의 할당과 생성자의 몸체부분의 실행만으로 객체생성이 완료된다.
 - 생성자가 선언되지 않았으면, 컴파일러는 디폴트 생성자라는 것을 자동으로 삽입해 호출한다. 디폴트 생성자는 이후에 공부한다.

### 멤버 이니셜라이저를 이용한 변수 및 const상수의 초기화
 - **멤버 이니셜라이저는 객체가 아닌 멤버의 초기화에도 사용할 수 있다.**
```
class SimpleClass
{
private:
	int num1;
	int num2;
public:
	SimpleClass(int n1, int n2) : num1(n1)		// 멤버 이니셜라이저를 이용한 멤버 초기화
	{
		num2 = n2;
	}
}
```
   - 위의 예시에서 `: num(n1)` 구문은 num1을 n1의 값으로 초기화하라는 뜻이다.
 - 이니셜라이저를 이용한 장점
   - 초기화의 대상을 명확히 인식할 수 있다.
   - 성능에 약간의 이점이 있다.
 - **이니셜라이즈를 이용하면 선언과 동시에 초기화가 이루어지는 형태로 바이너리 코드가 생성된다.**
   - 위의 예시는 다음과 동일해진다.  
`int num1 = n1; int num2; num2 = n2;`
   - **또한 이러한 특징으로 인해 `const` 멤버변수와 참조자 또한 이니셜라이즈를 이용해 초기화할 수 있다.**

## 디폴트 생성자(Default Constructor)

### 디폴트 생성자
 - 메모리 공간의 할당 이후에 생성자의 호출까지 완료되어야 '객체'라 할 수 있다.
   - 즉 객체가 되기 위해서는 반드시 하나의 생성자가 호출되어야 한다.
   - 이러한 기준에 예외를 뒤지 않기 위해 생성자를 정의하지 않는 클래스에서는 컴파일러에 의해 디폴트 생성자라는 것이 자동으로 삽입된다.
 - 다음 두 클래스는 완전히 동일하다.
```
class AAA
{
private:
	int num;
public:
	int GetNum { return num; }
}
```

```
class AAA
{
private:
	int num;
public:
	AAA(){ }		// 디폴트 생성자
	int GetNum { return num; }
}
```
 - 모든 객체는 한 번의 생성자 호출을 동반한다. 이는 new를 이용한 객체의 생성에도 해당된다. 따라서 다음과 같이 생성해도 생성자가 호출되게 된다.  
`AAA *ptr = new AAA`

### 생성자 불일치
 - 매개변수가 void형으로 생성되는 디폴트 생성자는 생성자가 하나도 정의되어 있지 않을 때에만 삽입된다.
 - 아래와 같이 정의된 클래스에는 디폴트 생성자가 삽입되지 않는다.
```
class SoSimple
{
private:
	int num;
public:
	SoSimple(int n) : num(n) { }
}
```
   - 따라서 다음의 형태에 따라 생성 가능여부가 갈린다.
```
// 정의된 생성자에 따라 멤버변수를 초기화해주므로 가능하다.
SoSimple simObj1(10);
SoSimple *simPtr1 = new SoSimple(2);

// 생성자가 정의되지도, 자동으로 삽입되지도 않아서 아래의 형태는 불가능하다.
SoSimple simObj1;
SoSimple *simPtr1 = new SoSimple;
```
   - 위의 형태로도 객체를 생셩하길 원한다면 다음의 형태로 생성자를 추가해야 한다.  
`SoSimple() : num(0) { }`

## private 생성자
 - 클래스 내부에서 객체를 생성한다면, 생성자가 private으로 선언되어 된다.
 - 다음은 private생성자를 사용하는 클래스 예제이다.
```
class AAA
{
	private:
		int num;
		AAA(int n) : num(n) {}			// private 생성자
	public:
		AAA& CreateInitObj(int n) const	// 생성자를 호출하는 함수
		{
        AAA *ptr = new AAA(n);
        return *ptr;
    }
}
```
 - 자세한 설명 : https://mufflemumble.tistory.com/14

## 소멸자의 이해와 활용
 - 객체생성시 반드시 호출되는 것이 생성자라면, 객체소멸시 반드시 호출되는 것은 소멸자이다.
 - 소멸자는 다음의 형태를 가진다.
   - 클래스의 이름 앞에 '~'가 붙은 형태의 이름을 갖는다.
   - 생성자와 마찬가지로 반환형이 선언되어 있지 않으며, 실재로 반환하지 않는다.
   - 배개변수는 void형으로 선언되어야 하기 때문에 오버로딩도, 디폴트 값 설정도 불가능하다.
 - 다음은 간단한 소멸자의 예시다.
```
class AAA
{
public:
	AAA() { }		// 생성자
	~AAA() { }		// 소멸자
}
```
 - 소멸자는 대개 생성자에서 할당한 리소스의 소멸에 사용된다.
   - 생성자에서 new를 이용해 메모리를 할당해 주었으면, 소멸자에서 delete를 이용해 메모리를 해제해준다.


# 4-4 클래스, 배열, this포인터

## 객체 배열
 - 객체 기반의 배열은 다음의 형태로 선언한다.  
`SoSimple arr[10];`
 - 이를 동적으로 할당하는 경우에는 다음처럼 선언한다.  
`SoSimple * ptrArr = new SoSimple[10];`
 - 위와 같이 배열 형식으로 선언해도 생성자는 호출이 되지만, 호출할 생성자를 별도로 명시하지 못해 생성자에 인자가 전달되지 않는다. 따라서 위의 형태로 배열이 생성되려면, 매개변수가 void형인 다음 형태의 생성자가 반드시 정의되어 있어야 한다.  
`SoSimple() { ... }		// 함수의 인자가 void`

## 객체 포인터 배열
 - 객체 포인터 배열은 객체의 주소 값 저장이 가능한 포인터 변수로 이뤄진 배열이다. 다음의 형태로 선언된다.
```
Person *parr[3];				// 포인터 배열 선언
for (int i = 0; i < 3; i++)		// 각각의 포인터에 대한 생성자 호출
{ parr[i] = new Person(...); }
```

## this 포인터

### this 포인터
 - 멤버함수 내에서는 `this`라는 이름의 포인터를 사용할 수 있는데, 이는 객체 자신을 가리키는 용도로 사용되는 포인터이다.
```
SoSimple *GetThisPointer() { return this; }		// this를 이용해 자기 자신의 주소값을 반환하는 함수

SoSimple sim1(100);								// sim1객체 생성
SoSimple *ptr1 = sim.GetThisPointer();			// sim1객체의 주소 값 저장
```
   - `this`는 객체 자신의 주소 값을 의미한다.
   - `this`포인터는 그 주소 값과 자료형이 정해져 있지 않고, 선언된 클래스의 형식과 위치에 따라 달라진다.

### this 포인터의 활용
 - this 포인터는 멤버변수와 매개변수의 이름이 같을 때 둘을 구분짓기 위해 사용하기 유용하다.
```
class ThisClass
{
private:
	int num;					// 클래스 멤버변수 num
public:
	void ThisFunc(int num)		// 함수의 매개변수 num
	{
		this->num = 207;		// 클래스 멤버변수 값 변경
		num = 105;				// 함수 매개변수 값 변경
	}
}
```

### Self-Reference의 반환
 - this 포인터를 이용해 객체가 자신의 참조에 사용할 수 있는 참조자의 반환문을 구성할 수 있다.
```
SelfRef& Adder(int n) { num += n; return *this; }				// 자기 자신의 참조값 반환
selfRef& ShowTwoNum() { cout << num << endl; return *this; }	// 자기 자신의 참조값 반환

SelfRef obj(3);													// 객체 생성
SelfRef &ref = obj.Adder(2);									// 참조값 반환 함수를 이용해 객체 참조
ref.Adder(1).ShowTwoNum().Adder(2);								// 반환되는 참조값을 바탕으로 연속적으로 함수 호출
```