# 5-1 복사 생성자와의 첫 만남.

## c++스타일의 초기화

### 변수의 초기화
 - 일반적인 방식의 초기화는 다음과 같다.
```
int num = 20;
int &ref = num;
```
 - c++에서는 다음과 같은 초기화도 가능하다. 두 초기화의 방식은 결과적으로 동일하다.
```
int num(20);
int &ref(num);
```
### 객체의 초기화
 - 객체 또한 다음과 같은 초기화가 가능하다.
```
SoSimple sim1(10, 20);
SoSimple sim2 = sim1;
```
   - `SoSimple sim2 = sim1;` 구문은 `SoSimple sim2(sim1);`으로 자동적으로 복사된다.
   - `sim2`가 생성된 다음에 `sim1`과 `sim2`간에 멤버 대 멤버의 복사가 일어나 `sim2`의 멤버변수도 `sim1`의 멤버변수와 동일하게 초기화된다.

### SoSimple sim2(sim1);
 - 위의 문장에 담겨있는 내용을 정리하면 다음과 같다.
   - SoSimple형 객체를 생성하라.
   - 객체의 이름은 sim2로 정한다.
   - sim1을 인자로 받을 수 있는 생성자의 호출을 통해 객체생성을 완료한다.
 - 즉 위의 객체생성문에서 호출하고자 하는 생성자는 다음과 같이 soSimple객체를 인자로 받을 수 있다.  
`SoSimple(SoSimple &copy) { ... }`

## 복사 생성자
 - 객체 내에서 동일한 객체의 멤버 대 멤버 복사를 하여 초기화하는 생성자를 가리켜 복사 생성자라고 한다.
 - 복사 생성자는 다음과 같이 정의된다.
```
SoSimple(const SoSimple &copy)
    : num1(copy.num1), num2(copy.num2)
{ ... }
```
   - 복사 생성자는 생성자의 정의 형태가 독특해서 붙은 이름이 아니라, 생성자가 호출되는 시점이 다른 일반 생성자와 차이가 있기 때문에 이름붙여졌다.
   - 원본을 변경시키는 것을 방지하기 위해 매개변수에 키워드 `const`를 사용하는 것이 좋다.
 - 복사 생성자의 매개변수 선언에 `const`는 필수가 아니지만, 참조형을 선언하는 `&`는 반드시 필수이다. 이유는 추후에 공부한다.

### 자동으로 삽입되는 디폴트 복사 생성자
 - 복사 생성자를 정의하지 않으면 멤버 대 멤버의 복사를 진행하는 디폴트 복사 생성자가 자동으로 삽입된다.
   - 디폴트 복사 생성자는 다음과 동일하다.
```
SoSimple(const SoSimple &copy)
    : num1(copy.num1), num2(copy.num2)
{ (empty) }
```

### explict
 - 묵시적 변환이 많이 발생하는 코드일수록 결과를 예측하기 어려워지기 때문에 자동 변환이 항상 좋은 것은 아니다.
 - `SoSimple sim2 = sim1;`과 같은 복사 생성자의 목시적 호출을 허용하고 싶지 않을 때 `explict` 키워드로 방지할 수 있다.
```
explict SoSimple(const SoSimple &copy)
    : num1(copy.num1), num2(copy.num2)
{ (empty) }
```
   - `explict` 키워드를 사용하면 `SoSimple sim2(sim1);`과 같은 구문으로만 복사 생성이 가능하다.


# 5-2 깊은 복사와 얕은 복사
 - 디폴트 복사 생성자는 멤버 대 멤버의 복사를 진행한다. 그리고 이러한 방식의 복사를 가리켜 '얕은 복사'라 하는데 이는 멤버변수가 힙의 메모리 공간을 참조하는 경우에 문제가 발생한다.

## 디폴트 복사 생성자의 문제점
 - 디폴트 복사 생성자를 사용하여 객체를 복사할 시, 문자열과 같은 주소 참조 형식의 매개변수에 관해서는 데이터가 아닌 주소만을 복사해온다.
   - 만일 소멸자에 `delete []`와 같은 메모리 해제 함수가 있는 객체를 복사 생성할 경우, 한 객체를 소멸시키면, 주소로 참조된 데이터 또한 해제되기 때문에 남은 객체는 해당 데이터를 읽을 수 없는 상황이 생긴다. 또한 이미 지워진 데이터에 또 `delete []`를 사용하게 되기 때문에 문제가 발생한다.

## 깊은 복사를 위한 복사 생성자의 정의
 - 객체 복사 생성과정에서 주소만을 복사하는 것이 아니라 데이터를 새로 생성하는 방식을 '깊은 복사'라 한다.
 - 깊은 복사는 다음과 같이 작성할 수 있다.
```
Person(const Person & copy) : age(copy.age)
{
	name = new char[strlen(copy.name) + 1];
	strcpy(name, copy.name);
}
```


# 5-3 복사 생성자의 호출 시점

## 복사 생성자가 호출되는 시점
 - 복사 생성자가 호출되는 시점은 크게 세 가지로 구분할 수 있다.
   - 기존에 생성된 객체를 이용해 새로운 객체를 초기화하는 경우(앞서 보인 경우)
   - Call-by-Value 방식의 함수호출 과정에서 객체를 인자로 전달하는 경우
   - 객체를 반환하되, 참조형으로 반환하지 않는 경우
 - 위의 셋은 **객체를 새로 생성해야 한다. 단 생성과 동시에 동일한 자료형으로 객체를 초기화시켜야 한다.**는 공통점이 있다.
 - 복사 생성자의 호출횟수는 프로그램의 성능과도 관계있기 때문에 호출의 시기를 잘 이해해야 한다.

### 메모리 공간의 할당과 초기화가 동시에 일어나는 상황
 - 다음과 같은 상황들에서 메모리 할당과 초기화가 동시에 일어난다.
   - 변수 선언
   - 함수의 매개변수
   - 객체 반환  
```
int num1 = num2;
```
```
int SimpleFunc(int n) { ... }

SimpleFunc(num);	// 호출되는 순간 매개변수 n이 할당과 동시에 num으로 초기화
```
```
int SimpleFunc(int n) { return n; }		// 반환하는 순간 메모리 공간이 할당되며 n으로 초기화

cout << SimpleFunc(num) << endl;
```
 - 위의 상황들은 객체를 대상으로 해도 동일하다.
```
SoSimple obj2 = obj1;
```
```
SoSimple SimpleFuncObj(SoSimple ob) { ... }

SoSimple obj;
SimpleFuncObj(obj)		// 호출되는 순간 매개변수 ob이 할당과 동시에 obj으로 초기화
```
```
SoSimple SimpleFuncObj(SoSimple ob) { return ob; }	// 반환하는 순간 메모리 공간이 할당되며 ob으로 초기화
```

### 메모리 할당 이후, 복사 생성자를 통한 초기화
 - 메모리를 할당한 이후에는 복사 생성자를 호출해 초기화를 하게 된다.
 - 함수의 매개변수에 대한 복사
   - 아래의 예시에서 초기화의 대상은 ob 객체이다.
   - ob객체는 메모리를 새로 할당받으며 복사 생성자를 호출하여 obj를 복사받게 된다.
```
SoSimple SimpleFuncObj(SoSimple ob) { ... }		// ob 할당 후 ob의 복사 생성자로 obj 복사

SoSimple obj;
SimpleFuncObj(obj)
```
 - 객체 반환에 대한 복사
   - 객체를 반환하게 되면 '임시객체'라는 것이 생성되고, 이 객체의 복사 생성자가 호출되면서 return문에 명시된 객체의 인자로 전달된다.
   - 즉 최종적으로 반환되는 객체는 새롭게 생성되는 임시객체이다.
```
SoSimple SimpleFuncObj(SoSimple ob) { return ob; }	// 임시객체 생성 후 임시객체의 복사 생성자로 ob 복사
```

### 임시객체가 소멸하는 때
```
class Temporary { ... };

Temporary TempFunc(Temporary ob) { return ob; }

int main()
{
	Temporary(100);		// 임시객체를 직접 생성하는 방법
	Temporary(200).ShowInfo();		// 임시객체를 생성하고, 생성된 객체를 바탕으로 함수 호출
	const Temporary &ref = Temporary(300);		// 임시객체를 생성한 후, 참조자로 객체 참조
	Temporary temp = TempFunc(ref);		// 함수에서 반환되는 임시객체를 temp로 할당해줌
}
```
 - 클래스 외부에서 객체의 멤버함수를 호출하기 위해 필요한 것은 다음 세 가지 중 하나이다.
   - 객체에 붙여진 이름
   - 객체의 참조 값(객체 참조에 사용되는 정보)
   - 객체의 주소 값
 - 임시객체가 생성된 위치에는 임시객체의 참조 값이 반환된다.
 - 임시객체는 다음 행으로 넘어가면 바로 소멸된다.
 - 하지만 참조자에 참조되는 임시객체는 바로 소멸되지 않는다.