# 인터페이스

### 인터페이스의 선언 및 특성
 - 인터페이스는 `interface`라는 키워드를 이용하여 다음과 같은 형식으로 선언이 가능하다.
```
interface 인터페이스이름
{
  반환_형식 메소드이름1( 매개변수_목록 );
  반환_형식 메소드이름2( 매개변수_목록 );
  반환_형식 메소드이름3( 매개변수_목록 );
  ...
}
```
 - 인터페이스의 선언은 클래스의 선언과 비슷하지만 **메소드, 이벤트, 인덱서, 프로퍼티**만을 가질 수 있다.
 - 인터페이스는 구현부 없이 오로지 선언부만 있고, 접근 제한 한정자를 사용할 수 없고 모든 것이 `public`으로 선언된다.
 - 인터페이스는 인스턴스를 생성할 수 없다. 다만 인터페이스를 상속받ㄷ는 클래스의 인스턴스는 생성할 수 있다.
   - 파생 클래스는 인터페이스에 선언된 모든 메소드 및 프로퍼티를 구현해줘야 하며, 이 메소드들은 `public`한정자로 수식해야 한다.
 - 인터페이스는 인스턴스를 생성할 수 없지만, 참조를 만들 수 있다. 해당 참조에 파생 클래스의 객체의 위치를 담을 수도 있다.
   - 기반 클래스와 파생 클래스간의 관계를 인터페이스와 그 인터페이스를 상속받는 클래스에서도 동일하게 관계지을 수 있다.
 - **인터페이스는 클래스가 따라야 하는 약속이 될 수 있다. 이 약속은 인터페이스로부터 파생될 클래스가 어떤 메소드를 구현해야 할지를 정의한다.**

### 인터페이스를 상속하는 인터페이스
 - 인터페이스도 인터페이스를 상속할 수 있다. 주로 다음의 경우에 상속을 하게 된다.
   - 상속하려는 인터페이스가 소스 코드가 아닌 어셈블리로만 제공되는 경우 : .NET SDK에서 제공하는 인터페이스들이 그 예시로, 새로운 기능을 추가하기 위해선 상속시키는 수밖에 없다.
   - 상속하려는 인터페이스의 소스 코드를 갖고 있어도 이미 인터페이스를 상속하는 클래스들이 존재하는 경우 : 클래스는 반드시 인터페이스의 모든 메소드와 프로펕티를 구현해야 하므로 인터페이스를 수정하면 해당 인터페이스를 상속받는 모든 클래스에서 컴파일 에러가 발생한다. 이런 상황에서 기존의 소스 코드에 영향을 주지 않고 새로운 기능을 추가하기 위해 사용한다.
 - 인터페이스간의 상속 또한 클래스의 그것과 유사하게 시행할 수 있다.
```
interface 파생_인터페이스 : 부모_인터페이스
{
  // ...추가할 메소드 목록
}
```

### 인터페이스 다중 상속
 - 클래스는 죽음의 다이아몬드 문제로 인한 업캐스팅 문제 등으로 인해 여러 클래스를 한 번에 상속할 수 없다.
   - 죽음의 다이아몬드란 최초의 클래스가 두 개의 파생 클래스로부터 상속받고, 이 두 개의 파생 클래스를 다시 하나의 클래스가 상속하는 것을 말한다.
   - 이로 인해 자식 클래스는 부모 클래스 두 개중 어떠한 것의 조상 클래스를 상속받는지 아무도 알 수 없게 된다.
 - 인터페이스는 내용이 아닌 외형만을 물려주기 때문에 죽음의 다이아몬드 등의 문제가 발생하지 않고, 다중상속을 실행할 수 있다.
```
class 클래스_이름 : 인터페이스1, 인터페이스2, ...
{
    // ...모든 메소드의 구현부
}
```

### 인터페이스의 기본 구현 메소드
 - 인터페이스에 새로운 메소드를 추가할 때 기본적인 구현체를 갖도록 해 기존에 있는 파생 클래스에서의 컴파일 에러를 막을 수 있다.
 - 인터페이스의 기본 구현 메소드는 인터페이스 참조로 업캐스팅했을 때만 사용할 수 있기 때문에 프로그래머가 파생 클래스에서 인터페이스에 추가된 메소드를 호출할 가능성도 없다.
```
interface ILogger
{
  void WriteLog(string message);
  // 기본 구현된 WriteError 메소드
  void WriteError(string error) {
    WriteLog($"Error: {error}");
  }
}

class ConsoleLogger : Ilogger { 
  public void WriteLog(string message) { ... }
}

Ilogger logger = new ConsoleLogger();
logger.WriteLog("System Up");       // OK
logger.WriteError("System Fail");   // OK

ConsoleLogger clogger = new ConsoleLogger();
clogger.WriteLog("System Up");      // OK
clogger.WriteError("System Fail");  // Compile Error
```

### 추상 클래스
 - 추상 클래스는 모든 것이 클래스와 동일하지만, 클래스와 달리 인스턴스를 가질 수는 없다.
 - 다만 추상 클래스는 추상 메소드를 가질 수 있다. 추상 메소드로 하여금 클래스를 인터페이스처럼 사용할 수 있게 해준다.
   - C# 컴파일러는 추상 메소드가 반드시 `public`, `protected`, `internal`, `protected internal` 한정자 중 하나로 수식될 것을 강요한다.
   - 추상 클래스를 상속받은 클래스에서 추상 메소드를 오버라이딩 할 때에도 `override`키워드를 사용한다.
   - 추상 메소드는 추상 클래스를 사용하는 프로그래머가 그 기능을 정의하도록 강제할 수 있다. 
 - 추상 클래스 또한 추상 클래스를 상속받을 수 있다.
 - 추상 클래스와 추상 메소드는 `abstract`한정자를 이용해 선언할 수 있다.
```
abstract class 클래스이름
{
  // 클래스와 동일하게 구현
  public abstract void SomeMethod();
}
```