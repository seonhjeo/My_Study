# 062.개발 환경 구축

## 개발 환경 구축
- 응용 소프트웨어 개발을 위해 **개발 프로젝트를 이해하고 소프트웨어 및 하드웨어 장비를 구축하는 것**
- 개발 환경은 응용 소프트웨어가 운영될 환경과 유사한 구조로 구축
- 분석 단계의 산출물을 바탕으로 개발에 필요한 하드웨어와 소프트웨어를 선정
- 하드웨어와 소프트웨어의 성능, 편의성, 라이선스 등의 비즈니스 환경에 적합한 제품들을 최종적으로 결정하여 구축

## 하드웨어 환경
- 하드웨어 환경은 사용자와의 인터페이스 역할을 하는 클라이언트와 클라이언트와 통신하여 서비스를 제공하는 서버로 구성
- 클라이언트의 종류 : PC, 스마트폰 등
- 서버의 종류
  - 웹서버(Web Server)
    - 클라이언트로부터 직접 요청을 받아 처리함
    - 저용량의 정적 파일들을 제공함
  - 웹 애플리케이션 서버(WAS)
    - 동적 서비스를 제공하거나 웹 서버와 데이터베이스 서버 또는 웹 서버와 파일 서버 사이에서 인터페이스 역할을 수행
  - 데이터베이스 서버(DB Server)
    - 데이터베이스와 이를 관리하는 DBMS를 운영함
  - 파일 서버(File Server)
    - 데이터베이스에 저장하기에는 비효율적이거나 서비스 제공을 목적으로 유지하는 파일들을 저장함

## 소프트웨어 환경
- 소프트웨어 환경은 클라이언트와 서버 운영을 위한 시스템 소프트우에어와 개발에 사용되는 개발 소프트웨어로 구성됨
- 시스템 소프트웨어의 종류 : 운영체제(OS), 웹서버 및 WAS운용을 위한 서버 프로그램, DBMS등
- 개발 소프트웨어의 종류
  - 요구사항 관리 도구 : 요구사항의 수집과 분석, 추적 등을 편리하게 도와주는 소프트웨어
  - 설계/모델링 도구 : UML을 지원하며 개발의 전 과정에서 설계 및 모델링을 도와주는 소프트웨어
  - 구현 도구 : 개발 언어를 통해 애플리케이션의 실제 구현을 지원하는 소프트웨어
  - 빌드 도구 : 구현 도구를 통해 작성된 소스의 빌드 및 배포, 라이브러리 관리를 지원하는 소프트웨어
  - 테스트 도구 : 모듈들이 요구사항에 적합하게 구현되었는지 테스트하는 소프트웨어
  - 형상 관리 도구 : 산출물들을 버전별로 관리하여 품질 향상을 지원하는 소프트웨어

## 웹서버의 기능
- HTTP/HTTPS지원 : 브라우저로부터 요청을 받아 응답할 때 사용되는 프로토콜
- 통신 기록 : 처리한 요청들을 로그 파일로 기록하는 기능
- 정적 파일 관리 : HTML, CSS 이미지 등의 정적 파일들을 저장하고 관리하는 기능
- 대역폭 제한 : 네트워크 트래픽의 포화를 방지하기 위해 응답 속도를 제한하는 기능
- 가상 호스팅 : 하나의 서버로 여러 개의 도메인 이름을 연결하는 기능
- 인증 : 사용자가 합법적인 사용자인지를 확인하는 기능

## 개발 언어의 선정 기준
- 적정성 : 새발하려는 소포트웨어의 목적에 적합해야 함
- 효율성 : 코드의 작성 및 구현이 효율적이어야 함
- 이식성 : 다양한 시스템 및 환경에 적용이 가능해야 함
- 친밀성 : 개발 언어에 대한 개발자들의 이해도와 활용도가 높아야 함
- 범용성 : 다른 개발 사례가 존재하고 여러 분야에서 활용되고 있어야 함


# 063. 소프트웨어 아키텍처

## 소프트웨어 아키텍처
- **소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체**
- 애플리케이션의 분할 방법과 분할된 모듈에 할당될 기능, 모듈 간의 인터페이스 등을 결정
- 소프트웨어 아키텍처 설계의 기본 원리에는 모듈화, 추상화, 단계적 분해, 정보은닉이 있다
- 소프트웨어의 골격이 되는 기본 구조로 기능적/비기능적 요구사항이 반영되어 있어 이해 관계자들의 의사소통 도구로도 사용됨

## 모듈화(Modularity)
- 소프트웨어의 성능 향상, 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 **시스템의 기능들을 모듈 단위로 나누는 것**을 의미
- 모듈의 크기를 너무 작게 나누면 개수가 많아져 모듈 간의 통합 비용이 많이 든다
- 모듈의 크기를 너무 크게 나누면 개수가 적어 통합 비용은 적게 들지만 모듈 하나의 개발 비용이 많이 든다

## 추상화(Abstraction)
- **전체적이고 포괄적인 개념을 설계한 후 구체화시켜 나가는 것**
- 완전한 시스템을 구축하기 전에 그 시스템과 유사한 모델을 만들어 여러 가지 요인들을 테스트할 수 있다.
- 추상화의 유형
  - 과정 추상화 : 자세한 수행 과정을 정의하지 않고, 전반적인 흐름만 파악할 수 있게 설계하는 방법
  - 데이터 추상화 : 데이터의 세부적인 속성이나 용도를 정의하지 않고, 데이터 구조를 대표할 수 있는 표현으로 대체하는 방법
  - 제어 추상화 : 이벤트 발생의 정확한 절차나 방법을 정의하지 않고, 대표할 수 있는 표현으로 대체하는 방법

## 단계적 분해(Stepwise Refinement)
- **상위의 중요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법**
- Niklaus Wirth에 의해 제안된 하향식 설계 전략
- 소프트웨어의 포괄적인 기능에서부터 시작하여 점차적으로 구체화하고, 알고리즘, 자료 구조 등 상세한 내역은 가능한 한 뒤로 미루어 진행

## 정보 은닉(Information Hiding)
- **모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법**
- 정보 은닉을 통해 모듈을 독립적으로 수행할 수 있다.
- 하나의 모듈이 변경되더라도 다른 모듈에 영향을 주지 않으므로 수정, 시험, 유지보수가 용이

## 상위 설계와 하위 설계
- 소프트웨어 개발의 설계 단계는 크게 상위 설계와 하위 설계로 구분할 수 있다.
- 상위 설계
  - 별칭 : 아키텍처 설계, 예비 설계
  - 설계 대상 : 시스템의 전체적인 구조
  - 세부 목록 : 구조, DB, 인터페이스
- 하위 설계
  - 별칭 : 모듈 설계, 상세 설계
  - 설계 대항 : 시스템의 내부 구조 및 행위
  - 세부 목록 : 컴포넌트, 자료구조, 알고리즘

## 소프트웨어 아키텍처의 품질 속성
- 소프트웨어 아키텍처가 이해 관계자들이 요구하는 수준의 품질을 유지 및 보장할 수 있게 설계되었는지 확인하기 위해 품질 평가 요소들을 구체화시켜 놓은 것
- 품질 평가 요소의 종류
  - 시스템 측면 : 성능, 보안, 가용성, 기능성, 사용성, 변경 용이성, 확장성 등
  - 비즈니스 측면 : 시장 적시성, 비용과 혜택, 예상 시스템 수명, 목표 시장, 공개일정 등
  - 아키텍처 측면 : 개념적 무결성, 정확성, 완결성, 구축 가능성, 변경성, 시험성 등 

## 소프트웨어 아키텍처의 설계 과정
1. 설계 목표 설정 : 요구사항을 분석하여 전체 시스템의 설계 목표 설정
2. 시스템 타입 결정 : 시스템과 서브시스템의 타입을 결정하고, 아키텍처 패턴 선택
3. 아키텍처 패턴 적용 : 시스템의 표준 아키텍처 설계
4. 서브시스템 구체화 : 서브시스템의 기능 및 서브시스템 간의 상호작용을 위한 동작과 인터페이스 정의
5. 검토 : 설계 목표, 요구사항, 설계의 기본 원리 등을 만족하는지 아키텍처 검토

## 협약(Contract)에 의한 설계
- **컴포넌트를 설계할 때 클래스에 대한 여러 가정을 공유할 수 있도록 명세한 것**
- 컴포넌트에 대한 정확한 인터페이스를 명세
- 명세에 포함될 조건
  - 선행 조건 : 오퍼레이션이 호출되기 전에 참이 되어야 할 조건
  - 결과 조건 : 오퍼레이션이 수행된 후 만족되어야 할 조건
  - 불변 조건 : 오퍼레이션이 실행되는 동안 항상 만족되어야 할 조건


# 064. 아키텍처 패턴(Patterns)
- **아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제**
- 소프트웨어 시스템의 구조를 구성하기 위한 기본적인 윤곽 제시
- 아키텍처 패턴에는 서브시스템들과 그 역할이 정의되어 있다
- 서브시스템 사이의 관계와 여러 규칙/지침 등이 포함되어 있다
- 주요 아키텍처 패턴의 종류
  - 레이어 패턴
  - 클라이언트-서버 패턴
  - 파이프-필터 패턴
  - 모델-뷰-컨트롤러 패턴

## 레이어 패턴(Layers Pattern)
- **시스템을 계층으로 구분하여 구성하는 패턴**
- 하위 계층은 상위 계층에 대한 서비스 제공자가 되고, 상위 계층은 하위 계층의 클라이언트가 된다
- 서로 마주보는 두 계층 사이에서만 상호작용이 이루어진다.
- 대표적으로 OSI 참조모델이 있다

## 클라이언트-서버 패턴(Client-Server Pattern)
- **하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성된 패턴**
- 사용자가 클라이언트를 통해 서버에 요청하면 클라이언트가 응답을 받아 사용자에게 제공하는 방식

## 파이프-필터 패턴(Pipe-Filter Pattern)
- **데이터 스트림 절차의 각 단계를 필터로 캡슐화하여 파이프를 통해 전송하는 패턴**
- 앞 시스템의 처리 결과물을 파이프를 통해 전달받아 처리한 후 그 결과물을 다시 파이프를 통해 다음 시스템으로 넘겨주는 패턴 반복
- 데이터 변환, 버퍼링, 동기화 등에 주로 사용되며 대표적으로 UNIX의 쉘이 있다.

## 모델-뷰-컨트롤러 패턴(Model-View-Controller Pattern)
- **서브시스템을 모델, 뷰, 컨트롤러로 구조화하는 패턴**
- 컨트롤러가 사용자의 요청을 받으면 핵심 기능과 데이터를 보관하는 모델을 이용하여 뷰에 정보를 출력하는 구조
- 여러 개의 뷰 생성 가능
- 한 개의 모델에 대해 여러 개의 뷰를 필요로 하는 대화형 애플리케이션에 적합

## 기타 패턴
- 마스터-슬레이브 패턴 : 슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식으로 작업을 수행하는 패턴 (장애 허용 시스템, 병렬 컴퓨팅 시스템)
- 브로커 패턴 : 사용자가 원하는 서비스와 특성을 브로커 컴포넌트에 요청하면 브로커 컴포넌트가 요청에 맞는 컴포넌트와 사용자를 연결해주는 패턴 (분산 환경 시스템)
- 피어-투-피어 패턴 : 피어라 불리는 하나의 컴포넌트가 클라이언트가 될수도, 서버가 될수도 있는 패턴 (파일 공유 네트워크)
- 이벤트-버스 패턴 : 소스가 특정 채널에 이벤트 메시지를 발행하면 해당 채널을 구독한 리스너들이 메시지를 받아 이벤트를 처리하는 패턴 (알림 서비스)
- 블랙보드 패턴 : 모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근이 가능한 패턴 (음성인식, 차량식별, 신호해석)
- 인터프리터 패턴 : 프로그램 코드의 각 라인을 수행하는 방법을 지정하고, 기호마다 클래스를 갖도록 구성된 패턴 (번역기, 컴파일러, 인터프리터)


# 065.객체지향

## 객체지향(Object-Oriented)
- **각 요소들을 객체로 만든 후 객체들을 조립해서 소프트웨어를 개발하는 기법**
- 구조적 기법의 문제점으로 인한 소프트웨어 위기의 해결책으로 채택되어 사용되고 있다
- 소프트웨어의 재사용 및 확장이 용이하여 고품질의 소프트웨어를 빠르게 개발할 수 있고 유지보수가 쉽다
- 객체지향의 구성 요소 : 객체, 클래스, 메시지
- 객체지향의 특징 : 캡슐화, 상속, 다형성, 연관성

## 객체(Object)
- **데이터와 이를 처리하기 위한 함수를 묶어 놓는 소프트웨어 모듈**
- 데이터 : 객체가 가지고 있는 정보로, 속성이나 상태, 분류 등
- 함수
  - 객체가 수행하는 기능으로 객체가 갖는 데이터를 처리하는 알고리즘
  - 객체의 상태를 참조하거나 변경하는 수단

## 클래스(Class)
- **공통된 속성과 연산을 갖는 객체의 집합**
- 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀
- 클래스에 속한 각각의 객체를 인스턴스(Instance)라고 한다

## 메시지(Message)
- **객체들 간의 상호작용을 하는 데 사용되는 수단**, 객체에게 어떤 행위를 하도록 지시하는 명령 또는 요구사항
- 메시지를 받는 객체는 대응하는 연산을 수행하여 예상된 결과를 반환

## 캡슐화(Encapsulation)
- **외부에서의 접근을 제한하기 위해 인터페이스를 제외한 세부 내용을 은닉하는 것**
- 캡슐화된 객체는 외부 모듈의 변경으로 인한 파급 효과가 적다
- 객체들 간에 메시지를 주고받을 때 상대 객체의 세부 내용은 알 필요가 없으므로 인터페이스가 단순해지고 객체 간 결합도가 낮아진다

## 상속(Inheritance)
- **상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것**
- 하위 클래스는 물려받은 속성과 연산을 다시 정의하지 않아도 즉시 자신의 속성으로 사용할 수 있다.
- 하위 클래스는 상속받은 속성과 연산 외에 새로운 속성과 연산을 첨가하여 사용할 수 있다

## 다형성(Polymorphism)
- **하나의 메시지에 대해 각각의 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력**
- 객체들은 동일한 메소드명을 사용하며 같은 의미의 응답을 한다

## 연관성(Relationship)
- **두 개 이상의 객체들이 상호 참조하는 관계**
- 연관성의 종류
  - is member of(연관화, Association) : 두 개 이상의 객체가 상호 관련되어 있음을 의미
  - is instance of(분류화, Classfication) : 동일한 형의 특성을 갖는 객체들을 모아 구성하는 것
  - is part of(집단화, Aggregation) : 관련 있는 객체들을 묶어 하나의 상위 객체를 구성하는 것
  - is a
    - 일반화(Generalization) : 공통적인 성질들로 추상화한 상위 객체를 구성하는 것
    - 특수화/상세화(Specialization) : 상위 객체를 구체화하여 하위 객체를 구성하는 것


# 066.객체지향 분석 및 설계

## 객체지향 분석(OOA; Object Oriented Analysis)
- **사용자의 요구사항과 관련된 객체, 속성, 연산, 관계 등을 정의하여 모델링하는 작업**
- 개발을 위한 업무를 객체와 속성, 클래스와 멤버, 전체와 부분 등으로 나누어 분석
- 클래스를 식별하는 것이 객체지향 분석의 주요 목적

## 객체지향 분석의 방법론
- Rumbaugh 방법 : 분석 활동을 객체 모델, 동적 모델, 기능 모델로 나누어 수행
- Booch 방법
  - 미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용
  - 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의
- Jacobson 방법 : 유스케이스를 강조하여 사용
- Coad & Yourdon 방법
  - E-R다이어그램을 사용해 객체의 행위를 모델링함
  - 객체 식별, 구조 식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성
- Wirfs-Brock 방법
  - 분석과 설계 간의 구분이 없고, 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행함

## 럼바우 분석 기법
- **모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법**
- 객체 모델링 기법(OMT)이라고도 한다
- 분석 활동은 객체(Object) 모델링 -> 동적(Dynamic) 모델링 -> 기능(Functional) 모델링 순으로 이루어진다
- 객체 모델링 : 정보(Information) 모델링이라고도 하며, 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 객체 다이어그램으로 표시하는 것
- 동적 모델링 : 상태 다이어그램을 이용하여 시간의 흐름에 따른 객체들 간의 제어흐름, 상호작용, 동작순서 등의 동적인 행위를 표현하는 모델링
- 기능 모델링 : 자료 흐름도를 이용하여 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링

## 객체지향 설계 원칙
- **변경이나 확장에 유연한 시스템을 설계하기 위해 지켜져야 할 원칙**
- SRP, OCP, LSP, ISP, DIP의 다섯 가지 원칙의 앞 글자를 따 SOLID원칙이라고 부른다.
- 객체지향 설계 원칙의 종류
  - 단일 책임 원칙(SRP) : 객체는 단 하나의 책임만 가져야 한다
  - 개방-폐쇄 원칙(OCP) : 기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계해야 한다
  - 리스코프 치환 원칙(LSP) : 자식 클래스는 최소한 부모 클래스의 기능은 수행할 수 있어야 한다
  - 인터페이스 분리 원칙(ISP) : 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다
  - 의존 역전 원칙(DIP) : 의존 관계 성립시 추상성이 높은 클래스와 의존 관계를 맺어야 한다.


# 067.모듈

## 모듈(Module)
- **모듈화를 통해 분리된 시스템의 각 기능**
- 모듈화는 소프트웨어의 성능을 향상시키거나 시스템의 수정 및 재사용, 유지 관리 등을 위해 시스템의 기능들을 모듈 단위로 분해는 것을 의미
- 모듈의 기능적 독립성은 소프트웨어를 구성하는 각 모듈의 기능이 서로 독립됨을 의미
- 모듈의 독립성은 결합도와 응집도에 의해 측정됨

## 결합도(Coupling)
- **모듈간에 상호 의존하는 정도** 또는 두 모듈 사이의 연관관계
- 결합도가 약할수록 품질이 높고, 강할수록 품질이 낮다
- 결함도의 종류와 강도
  - 내용 결합도(Content Coupling)    (가장 강함)
  - 공통 결합도(Common Coupling)
  - 외부 결합도(External Coupling)
  - 제어 결합도(Control Coupling)
  - 스탬프 결합도(Stamp Coupling)
  - 자료 결합도(Data Coupling)       (가장 약함)

## 결합도의 종류
- 내용 결합도
  - 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도
- 공통 결합도
  - 공유되는 공통 데이터 영역을 여러 보듈이 사용할 때의 결합도
  - 파라미터가 아닌 모듈 밖에 선언된 전역 변수를 사용하여 전역 변수를 갱신하는 방식으로 상호작용하는 때의 결합도
- 외부 결합도
  - 어떤 모듈에서 선언한 데이터를 외부의 다른 모듈에서 참조할 때의 결합도
- 제어 결합도
  - 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 신호나 제어 요소를 전달하는 결합도
  - 하위 모듈에서 상위 모듈로 제어 신호가 이동하여 하위 모듈이 상위 모듈에게 처리 명령을 내리는 권리 전도 현상이 발생하게 됨
- 스탬프 결합도
  - 모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달될 때의 결합도
- 자료 결합도
  - 모듈 간의 인터페이스가 자료 요소로만 구성될 때의 결합도

## 응집도(Cohesion)
- **모듈의 내부 요소들이 서로 관련되어 있는 정도**
- 응집도가 강할수록 품질이 높고, 약할수록 품질이 낮다
- 응집도의 종류와 강도
  - 기능적 응집도(Functional Cohension)    (가장 강함)
  - 순차적 응집도(Sequential Cohension)
  - 교환적 응집도(Communication Cohension)
  - 절차적 응집도(Procedural Cohension)
  - 시간적 응집도(Temporal Cohension)
  - 논리적 응집도(Logical Cohension)
  - 우연적 응집도(Coincidental Cohension)   (가장 약함)

## 응집도의 종류
- 기능적 응집도
  - 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도
- 순차적 응집도
  - 모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도
- 교환적 응집도
  - 동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우의 응집도
- 절차적 응집도
  - 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도
- 시간적 응집도
  - 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도
- 논리적 응집도
  - 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도
- 우연적 응집도
  - 모듈 내부의 각 구성 요소들이 서로 관련 없는 요소로만 구성된 경우의 응집도

## 팬인(Fan-In) / 팬아웃(Fan-Out)
- **팬인은 어떤 모듈을 제어하는 모듈의 수**
- **팬아웃은 어떤 모듈에 의해 제어되는 모듈의 수**
- 팬인이 높다는 것은 재사용 측면에서 설계가 잘 되어있다고 볼 수 있다.
- 팬인이 높은 경우 단일 장애점이 발생할 수 있으므로 중점적인 관리 및 테스트가 필요하다

## N-S차트
- **논리의 기술에 중점을 두고 도형을 이용해 표현하는 방법**
- 박스 다이어그램, Chapin Chart라고도 한다
- GOTO나 화살표를 사용하지 않는다
- 연속, 선택 및 다중 선택, 반복의 3가지 제어 논리 구조로 표현
- 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는 데 적합


# 068. 단위 모듈

## 단위 모듈(Unit Module)
- 소프트웨어 구현에 필요한 여러 동작 중 **한 가지 동작을 수행하는 기능을 모듈로 구현한 것**
- 단위 모듈로 구현되는 하나의 기능을 단위 기능이라 부름
- 독립적인 컴파일이 가능하며, 다른 모듈에 호출되거나 삽입되기도 함
- 단위 모듈 구현 과정
  1. 단위 기능 명세서 작성 : 기능 및 코드 명세서나 설계 지침과 같은 단위 기능을 명세화하는 단계
  2. 입출력 기능 구현 : 입출력 기능을 위한 알고리즘 및 데이터를 구현하는 단계
  3. 알고리즘 구현 : 단위 기능벼로 모듈을 구현하는 단계

## IPC(Inter-Process Communication)
- **모듈 간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합**
- 복수의 프로세스를 수행하며 이뤄지는 프로세스 간 통신까지 구현이 가능
- IPC의 대표 메소드 5가지
  - Shared Memory : 공유 가능한 메모리를 구성하여 다수의 프로세스가 통신하는 방식
  - Socket : 네트워크 소켓을 이용해 네트워크를 경유하는 프로세스간에 통신하는 방식
  - Semaphore : 공유 자원에 대한 접근 제어를 통해 통신하는 방식
  - Pipes&named Pipes : Pipe랴고 불리는 선입선출 형태로 구성된 메모리를 여러 프로세스가 공유하여 통신하는 방식, 하나의 프로세스가 이용 중이면 다른 프로세스는 접근 불가
  - Message Queueing : 메시지가 발생하면 이를 전달하는 방식으로 통신하는 방식

## 단위 모듈 테스트
- **모듈이 정해진 기능을 정확히 수행하는지 검증하는 것**
- 단위 테스트(Unit Test)라고도 불림
- 단위 모듈 테스트의 기준은 단위 모듈에 대한 코드이므로 시스템 수준의 오류는 잡아낼 수 없다.

## 테스트 케이스(Test Case)
- **소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위한 테스트 항목에 대한 명세서**
- 테스트 케이스를 이용하지 않은 테스트는 특정 요소에 대한 검증이 누락되거나 불필요한 검증의 반복으로 인해 인력과 시간을 낭비할 수 있다.
- ISO/IEC/IEEE 29119-3 표준에 따른 테스트 케이스의 구성 요소
  - 식별자 : 항목 식별자, 일련번호
  - 테스트 항목 : 테스트 대상(모듈 또는 기능)
  - 입력 명세 : 입력 데이터 또는 테스트 조건
  - 출력 명세 : 테스트 케이스 수행 시 예상되는 출력 결과
  - 환경 설정 : 필요한 하드웨어나 소프트웨어의 환경
  - 특수 절차 요구 : 테스트 케이스 수행 시 특별히 요구되는 절차
  - 의존성 기술 : 테스트 케이스 간의 의존성


# 069.공통 모듈

## 공통 모듈
- **여러 프로그램에서 공통으로 사용할 수 있는 모듈**
- 자주 사용되는 계산식이나 매번 필요한 사용자 인증과 같은 기능들이 공통 모듈로 구성될 수 있다.
- 공통 모듈을 구현할 때는 해당 기능을 명확히 이해할 수 있도록 명세 기법을 준수해야 한다

## 공통 모듈 명세 기법의 종류
- 정확성(Correctness) : 시스템 구현 시 해당 기능이 필요하다는 것을 알 수 있도록 정확히 작성함
- 명확성(Clarity) : 해당 기능을 이해할 때 중의적으로 해석되지 않도록 명확하게 작성
- 완전성(Completeness) : 시스템 구현을 위해 필요한 모든 것을 기술
- 일관선(Consistency) : 공통 기능들 간 상호 충돌이 발생하지 않도록 작성
- 추적성(Traceability) : 기능에 대한 요구사항의 출처, 관련 시스템 등의 관계를 파악할 수 있도록 작성함

## 재사용(Reuse)
- **이미 개발된 기능들을 새로운 시스템이나 기능 개발에 사용하기 적합하도록 최적화하는 작업**
- 새로 개발하는데 필요한 비용과 시간을 절약할 수 있다.
- 누구나 이해할 수 있고 사용이 가능하도록 사용법을 공개해야 한다
- 재사용 규모에 따른 분류
  - 함수와 객체 : 클래스나 메소드 단위의 소스 코드 재사용
  - 컴포넌트 : 독립적인 업무 또는 기능을 수행하는 실행 코드 기반으로 작성된 모듈, 컴포넌트 자체에 대한 수정 없이 인터페이스를 통해 통신하는 방식으로 재사용
  - 애플리케이션 : 공통된 기능들을 제공하는 애플리케이션을 공유하는 방식으로 재사용

## 효과적인 모듈 설계 방향
- 결합도는 줄이고 응집도는 옾여서 모듈의 독립성과 재사용성을 높인다
- 복잡도와 중복성을 줄이고 일관성을 유지시킨다
- 모듈의 기능은 예측이 가능해야 하며 지나치게 제한적이어서는 안된다
- 모듈 크기는 시스템의 전반적인 기능과 구조를 이해하기 쉬운 크기로 분해한다
- 효과적인 제어를 위해 모듈 간의 계층적 관계를 정의하는 자료가 제시되어야 한다


# 070. 코드

## 코드(Code)
- **자료의 분류, 조합, 집계, 추출을 용이하게 하기 위해 사용하는 기호**
- 정보를 신속/정확/명료하게 전달할 수 있게 한다
- 일정한 규칙에 따라 작성된다
- 정보 처리의 효율과 처리된 정보의 가치에 많은 영향을 미친다

## 코드의 주요 기능
- 식별 기능 : 데이터 간의 성격에 따라 구분이 가능함
- 분류 기능 : 특정 기준이나 동일한 유형에 해당하는 데이터를 그룹화 할 수 있음
- 배열 기능 : 의미를 부여하여 나여할 수 있음
- 표준화 기능 : 다양한 데이터를 기준에 맞추어 표현할 수 있음
- 간소화 기능 : 복잡한 데이터를 간소화할 수 있음

## 코드의 종류
- 순차 코드(Sequence Code)
  - 자료의 발생 순서, 크기 순서 등 일정 기준에 따라 최초의 자료부터 차례로 일련번호를 부여하는 방법으로 순서 코드 또는 일련번호 코드라고도 함
  - ex) 1, 2, 3, 4, ...
- 블록 코드(Block Code)
  - 코드화 대상 항목 중에서 공통성이 있는 것끼리 블록으로 구분하고, 각 블록 내에서 일련번호를 부여하는 방법으로, 구분 코드라고도 함
  - ex) 1001~1100 : 총무부, 1101~1200 : 영업부
- 10진 코드(Decimal Code)
  - 코드화 대상 항목을 10진 분할하고, 다시 그 각각에 대해 10진 분할하는 방법을 필요한 만큼 반복하는 방법으로, 도서 분류식 코드라고도 함
  - ex) 1000 : 공학, 1100 : 소프트웨어 공학, 1110 : 소프트웨어 설계
- 그룹 분류 코드(Group Classification Code)
  - 코드화 대상 항목을 일정 기준에 따라 대분류, 중분류, 소분류 등으로 구분하고, 각 그룹 안에서 일련번호를 부여하는 방버
  - ex) 1-01-001 : 본사-총무부-인사계, 2-01-001 : 지사-총무부-인사계
- 연상 코드(Mnemonic Code)
  - 코드화 대상 항목의 명칭이나 약호와 관계있는 숫자나 문자, 기호를 이용하여 코드를 부여하는 방법
  - ex) TV-40 : 40인치 TV, L-15-220 : 15w 220v 램프
- 표의 숫자 코드(Significant Digit Code)
  - 코드화 대상 항목의 성질, 즉 길이, 넓이, 부피, 지름, 높이 등의 물리적 수치를 그대로 코드에 적용시키는 방법으로, 유효 숫자 코드라고도 함
  - ex) 120-720-1500 : 두께X폭X길이가 120X720X1500인 강판
- 합성 코드(Combined Code)
  - 필요한 기능을 하나의 코드로 수행하기 어려운 경우 2개 이상의 코드를 조합하여 만드는 방법
  - ex) 연상 코드 + 순차 코드, KE-711 : 대한항공 711기


# 071.디자인 패턴

## 디자인 패턴(Design Pattern)
- **모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제**
- 문제 및 배경, 실제 적용된 사례, 재사용이 가능한 샘플 코드 등으로 구성되어 있다
- 개발 과정 중에 문제가 발생하면 새 해결책을 구상하는 것보다 문제에 해당하는 디자인 패턴을 참고하여 적용하는 것이 더 효율적이다.
- GOF의 디자인 패턴은 생성 패턴, 구조 패턴, 행위 패턴으로 구분된다

## 생성 패턴(Creation Pattern)
- **클래스나 객체의 생성과 참조 과정을 정의하는 패턴**
- 추상 팩토리(Abstract Factory)
  - 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관/의존하는 객체들의 그룹으로 생성하여 추상적으로 표현함
  - 연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능
- 빌더(Builder)
  - 작게 분리된 인스턴스를 건축하듯이 조합하여 객체를 생성함
  - 객체의 생성 과정과 표현 방법을 분리하고 있어, 동일한 객체 생성에서도 서로 다른 결과를 만들어 낼 수 있음
- 팩토리 메소드(Factory Method)
  - 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴
  - 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당함
  - 가상 생성자(Virtual Constructor) 패턴이라고도 함
- 프로토타입(Prototype)
  - 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴
  - 일반적인 방법으로 객체를 생성하며, 비용이 큰 경우 주로 이용함
- 싱글톤(SingleTon)
  - 하나의 객체를 생성하면 생성된 객체를 어디서는 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수는 없음
  - 클래스 내에서 인스턴스가 하나뿐임을 보장하며, 불필요한 메모리 낭비를 최소화 할 수 있음

## 구조 패턴(Structurla pattern)
- **클래스나 객체들을 조합하여 더 큰 구조로 만드는 패턴**
- 어댑터(Adapter)
  - 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴
  - 기존의 클래스를 이용하고 싶지만 인터페이스가 일치하지 않을 때 이용
- 브리지(Bridge)
  - 구현부에서 추상층을 분리하여 서로가 독립적으로 확장할 수 있도록 구성한 패턴
  - 기능과 구현을 두 개의 별도 클래스로 구현
- 컴포지트(Composite)
  - 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 생성하는 패턴
  - 객체들을 트리 구조로 구성하여 디렉터리 안에 디렉터리가 있듯이 복합 객체 안에 복합 객체가 포함되는 구조를 구현할 수 있음
- 데코레이터(Decorator)
  - 객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴
  - 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현
- 퍼싸드(Facade)
  - 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴
  - 서브 클래스들 사이의 통합 인터페이스를 제공하는 Wrapper 객체가 필요함
- 플라이웨이트(Flyweight)
  - 인스턴스가 필요할 때마다 매번 생성하는 것이 아니고 가능한 한 공유해서 사용함으로써 메모리를 절약하는 패턴
  - 다수의 유사 객체를 생성하거나 조작할 때 유용하게 사용할 수 있음
- 프록시(Proxy)
  - 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴
  - 네트워크 연결, 메모리의 대용량 객체로의 접근 등에 주로 이용함

## 행위 패턴(Behavioural Pattern)
- **클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴**
- 책임 연쇄(Chain of responsibility)
  - 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴
  - 요청을 처리할 수 있는 각 객체들이 고리(Chain)로 묶여 있어 요청이 해결될 때까지 고리를 따라 책임이 넘어감
- 커맨드(Command)
  - 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴
  - 요청에 사용되는 각종 명령어들을 추상 클래스와 구체 클래스로 분리하여 단순화함
- 인터프리터(Interpreter)
  - 언어에 문법 표현을 정의하는 패턴
  - SQL이나 통신 프로토콜과 같은 것을 개발할 때 사용함
- 반복자(Iterator)
  - 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴
  - 내부 표현 방법의 노출 없이 순차적인 접근이 가능함
- 중재자(Mediator)
  - 수많은 객체들 간의 복잡한 상호작용(interface)를 캡슐화하여 객체로 정의하는 패턴
  - 객체 사이의 의존성을 줄여 결합도를 감소시킬 수 있음
- 메멘토(Memento)
  - 특정 시즘에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴
  - ctrl + z 와 같은 되돌리기 기능을 개발할 때 주로 이용
- 옵서버(Observer)
  - 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴
  - 일대다의 의존성을 정의함
  - 주로 분산된 시스템 간에 이벤트를 생성/발행하고 이를 수신해야 할 때 이용함
- 상태(State)
  - 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴
  - 객체 상태를 캡슐화하고 이를 참조하는 방식으로 처리함
- 전략(Strategy)
  - 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴
  - 클라이언트는 독립적으로 원하는 알고리즘을 선택하여 사용할 수 있으며, 클라이언트에 영향 없이 알고리즘의 변경이 가능함
- 템플릿 메소드(template Method)
  - 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴
  - 유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에서 정의함으로써 코드의 양을 줄이고 유지보수를 용이하게 해줌
- 방문자(Visitor)
  - 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴
  - 분리된 처리 기능은 각 클래스를 방분하여 수행함


# 072.개발 지원 도구

## 통합 개발 환경(IDE; Integrated Development Environment)
- **개발에 필요한 다양한 툴을 하나의 인터페이스로 통합하여 제공하는 환경**
- 통합 개발 환경을 제공하는 소프트웨어를 의미
- 코드를 실행하거나 테스트할 때 오류가 발생한 부분을 시각화하므로 수정이 용이

## 빌드 도구
- **소스 코드 파일들을 컴퓨터에서 실행할 수 있는 제품 소프트웨어로 변환하는 과정 또는 결과물**
- 빌드 도구는 전처리, 컴파일 등의 작업을 수행
- 대표적인 빌드 도구 : ANT, Maven, Gradle

## 기타 협업 도구
- **개발에 참여하는 사람들이 서로 다른 작업 환경에서 원활히 프로젝트를 수행할 수 있도록 도와주는 도구**
- 협업 소프트웨어, 그룹웨어 등으로도 불린다
- 일정 관리, 업무흐름 관리, 정보 공유, 커뮤니케이션 등의 업무 보조 도구가 포함됨


# 073.서버 개발

## 서버 개발
- **웹 애플리케이션의 로직을 구현할 서버 프로그램을 제작하여 웹 어플리케이션 서버에 탑재하는 것을 의미**
- 서버 개발에 사용되는 프로그래밍 언어에는 Java, JavaScript, Python, PHP, Ruby등이 있다.
- 각 프로그래밍 언어에는 해당 언어로 서버 프로그램을 개발할 수 있도록 지원하는 프레임워크가 있다.

## 서버 개발 프레임워크
- 서버 프로그램 개발 시 **다양한 네트워크 설정, 요청 및 응답 처리, 아키텍처 모델 구현 등을 손쉽게 처리할 수 있도록 클래스나 인터페이스를 제공하는 소프트웨어를 의미**
- 서버 개발 프레임워크의 대부분은 모델-뷰-컨트롤러 패턴을 기반으로 개발됨
- 서버 개발 프레임워크의 종류
  - Spring : JAVA를 기반으로 만듬, 전자정부 표준 프레임워크의 기반 기술로 사용되고 있음
  - Node.js : javaScript를 기반으로 만듬, 비동기 입출력 처리와 이벤트 위주의 높은 처리 성능을 갖고 있어 실시간으로 입출력이 빈번한 애플리케이션에 적합함
  - Django : Python 기반 프레임워크, 컴포넌트의 재사용과 플러그인화를 강조하여 신속한 개발이 가능하도록 지원
  - Codeigniter : PHP 기반 프레임워크, 인터페이스가 간편하며 서버 자원을 적게 사용
  - Ruby on Rails : Ruby 기반 프레임워크, 테스트를 위한 웹서버를 지원하며 데이터베이스 작업을 단순화/자동화시켜 개발 코드의 길이가 짧아지게 함으로써 신속한 개발 가능

## 서버 개발 과정
- **DTO/VO, SQL, DAO, Service, Controller를 각각 구현하는 과정**
- 구현 순서는 개발자가 임의로 변경할 수 있다.
- 개발하려는 서버 프로그램의 목적, 개발 언어, 규모 등의 이유로 통합하거나 세분화할 수 있다.
- 구현 과정
  - DTO/VO 구현
    - DTO : 데이터의 교환을 위해 생성되는 객체, VO : DTO와 동일하지만 읽기만 가능한 객체, 변경 불가능
    - 데이터 교환을 위해 사용할 객체를 만드는 과정
    - 송수신할 데이터의 자료형에 맞는 변수 및 객체 생성
  - SQL 구현
    - 데이터의 삽입, 변경, 삭제 등의 작업을 수행할 SQL문을 생성하는 과정
    - SQL문은 소스 코드 내에 직접 입력, 또는 별도의 XML파일로 관리
  - DAO 구현
    - DB에 접근하고 SQL을 활용하여 데이터를 실제로 조작하는 코드를 구현하는 과정
  - Service 구현
    - 사용자의 요청에 응답하기 위한 로직을 구현하는 과정
  - Controller 구현
    - 사용자의 요청에 적절한 서비스를 호출하여 그 결과를 사용자에게 반환하는 코드를 구현하는 과정


# 074.배치 프로그램

## 배치 프로그램(Batch Program)
- 배치 프로그램은 사용자와의 상호 작용 없이 **여러 작업들을 미리 정해진 일련의 순서에 따라 일괄적으로 처리하도록 만든 프로그램**
- 배치 프로그램의 필수 요소
  - 대용량 데이터 : 대량의 데이터를 가져오거나, 전달하거나, 계산하는 등의 처리가 가능해야 함
  - 자동화 : 심각한 오류가 발생하는 상황을 제외하고는 사용자의 개입 없이 수행되어야 함
  - 견고성 : 잘못된 데이터나 데이터 중복 등의 상황으로 중단되는 일 없이 수행되어야 함
  - 안정성/신뢰성 : 오류가 발생하면 오류의 발생 위치, 시간 등을 추적할 수 있어야 함
  - 성능 : 다른 응용 프로그램의 수행을 방해하지 않고 지정된 시간 내에 처리가 완료되야 함

## 배치 스케줄러(Batch Scheduler)
- **일괄 처리 작업이 설정된 주기에 맞춰 자동으로 수행되도록 지원해주는 도구**
- 특정 업무를 원하는 시간에 처리할 수 있도록 지원한다는 특성 때문에 잡 스케줄러라고도 불림
- 배치 스케줄러의 종류 : 스프링 배치, 쿼츠, 크론 등

## crontab 명령어 작성 방법
- `[분] [시] [일] [월] [요일] [명령어]`



1. 동적 서비스 제공 혹은 서버 사이에어 인터페이스 역할을 수행하는 서버
2. 범용성
3. 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체
4. 선행 조건
5. 시장 적시성, 비용과 혜택, 목표 시장
6. 단계적 분해
7. 레이어 패턴
8. 피어-투-피어 패턴
9. 상위 클래스의 모든 것을 하위 클래스가 물려받는 것
10. 분류화
11. 다형성
12. 자료 흐름도를 이용해 자료 흐름을 중심으로 처리 과정을 표현하는 모델링
13. SPICE
14. 결합도
15. 스탬프 결합도, 외부 결합도, 공통 결합도
16. 절차적 응집도
17. 자료 결합도
18. 팬인, 팬아웃
19. A, B, C
20. 단위 모듈
21. 테스트 케이스
22. 공유 메모리
23. 공통 기능들 간 상호 충돌이 발생하지 않는 것
24. 추적성
25. 재사용
26. 그룹 분류 코드
27. 배열 기능
28. 연관 코드
29. 어댑터
30. Decorater
31. 플라이웨이트
32. Command, Observer, State, Visitor
33. 메멘도
34. 전략
35. Gradle
36. IDEA
37. 서버 개발 프레임워크
38. Controller, DAO
39. 스프링 배치
40. 0 18 15 * * /dev/autobot.sh
41. 테스트 조건, 테스트 데이터, 예상 결과
42. ㄱ ㄷ ㅅ
43. 리스코프 치환 원칙
