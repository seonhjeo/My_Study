# 029.데이터베이스 개요

## 데이터저장소
- 데이터들을 논리적인 구조로 조직화하거나 물리적인 공간에 구축한 것
- 논리 데이터저장소는 데이터 및 데이터간의 연계성, 제약조건을 식별하여 논리적인 구조로 조직화한 것
- 물리 데이터저장소는 논리 데이터저장소를 소프트웨어가 운용될 환경의 물리적 특성을 고려해 실제 저장장치에 기록한 것

## 데이터베이스(Database)
- **공동으로 사용될 데이터를 중복을 배제하여 통합하고 저장장치에 저장해 항상 사용될 수 있도록 운영하는 운영 데이터**
- 데이터베이스의 구분
  - 통합된 데이터(Integrated Data) : 자료의 중복을 배제한 데이터들의 모임
  - 저장된 데이터(Stored Data) : 컴퓨터가 접근할 수 있는 저장 매체에 저장된 자료
  - 운영 데이터(Operational Data) : 조직의 고유한 업무를 수행하는 데 반드시 필요한 자료
  - 공용 데이터(Shared Data) : 여러 응용 시스템들이 공동으로 소유하고 유지하는 자료

## DBMS(데이터베이스 관리 시스템)
- **사용자의 요구에 따라 정보를 생성해주고 데이터베이스를 관리해주는 소프트웨어**
- 기존의 파일 시스템이 갖는 데이터의 종속성과 중복성 문제를 해결하기 위해 제안된 시스템
- DBMS의 필수 기능 3가지
  - 정의(Definition)기능 : 데이터의 형과 구조에 대한 정의, 이용 방식, 제약 조건 등을 명시하는 기능
  - 조작(Manipulation)기능 : 데이터 검색, 갱신, 삽입, 삭제 등을 위해 인터페이스 수단을 제공하는 기능
  - 제어(Control)기능 : 데이터의 무결성, 보안, 권한 검사, 병행 제어를 제공하는 기능

## 데이터의 독립성
- 데이터 독립성은 종속성에 대비되는 말로 논리적 독립성과 물리적 독립성이 있다.
  - 논리적 독립성 : 옹용 프로그램과 데이터베이스를 독립시킴으로써 데이터의 논리적 구조를 변경시키더라도 응용 프로그램은 영향을 받지 않음
  - 물리적 독립성 : 응용 프로그램과 보조기억장치 같은 물리적 장치를 독립시킴으로써 디스크를 추가/변경하더라도 응용 프로그램은 영향을 받지 않음

## 스키마(Schema)
- **데이터베이스의 구조와 제약조건에 관한 전반적인 명세를 기술한 것**
- 외부 스키마
  - 사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것
- 개념 스키마
  - 데이터베이스의 전체적인 논리 구조
  - 모든 응용 프로그램이나 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 데이터베이스로 하나만 존재
- 내부 스키마
  - 물리적 저장장치의 입장에서 본 데이터베이스의 구조
  - 실제로 저장될 레코드의 형식, 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타냄


# 030.데이터베이스 설계

## 데이터베이스 설계
- 사용자의 요구를 분석하여 컴퓨터에 저장할 수 있는 데이터베이스의 구조에 맞게 변형한 후, DBMS로 데이터베이스를 구현하여 일반 사용자들이 사용하게 하는 것

## 데이터베이스 설게 시 고려사항
- 무결성 : 삽입, 삭제, 갱신 등의 연산 후에도 데이터베이스에 저장된 데이터가 정해진 제약 조건을 항상 만조해야 함
- 일관성 : 데이터베이스에 저장된 데이터들 사이나, 특정 질의에 대한 응답이 처음부터 끝까지 변함없이 일정해야 함
- 회복 : 시스템에 장애가 발생했을 때 장애 발생 직전의 상태로 복구할 수 있어야 함
- 보안 : 불법적인 데이터의 노출 또는 변경이나 손실로부터 보호할 수 있어야 함
- 효율성 : 응답시간의 단축, 시스템의 생산성, 저장 공간의 최적화 등이 가능해야 함
- 데이터베이스 확장 : 데이터베이스의 운영에 영향을 주지 않으면서 지속적으로 데이터를 추가할 수 있어야 함

## 데이터베이스 설게 순서
1. 요구 조건 분석 (요구 조건 명세서 작성)
2. 개념적 설계 (개념 스키마, 트랜잭션 모델링, E-R 모델링)
3. 논리적 설계 (목표 DBMS에 맞는 논리 스키마 설계, 트랜잭션 인터페이스 설계)
4. 물리적 설계 (목표 DBMS에 맞는 물리적 구조의 데이터로 변환)
5. 구현 (목표 DBMS의 DDL로 데이터베이스 생성, 트랜잭션 작성)

## 요구 조건 분석
- **데이터베이스를 사용할 사람들로부터 필요한 용도를 파악하는 것**
- 사용자에 따른 수행 업무와 필요한 데이터 종류, 용도, 처리형태, 흐름, 제약조건 등 수집
- 수집된 정보를 바탕으로 요구 조건 명세 작성

## 개념적 설계(정보 모델링)
- 정보의 구조를 얻기 위해 현실 세계의 무한성과 계속성을 이해하고, 다른 사람과 통신하기 위해 **현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정**
- 개념 스키마 모델링과 트랜잭션 모델링을 병행 수행
- 요구 분석에서 나온 결과인 요구 조건 명세를 DBMS에 독립적인 E-R 다이어그램으로 작성
- DBMS에 독립적 개념 스키마 설계

## 논리적 설계(데이터 모델링)
- **현실 세계에서 발생하는 자료를 특정 DBMS가 지원하는 논리적 자료 구조로 변환시키는 과정**
- 개념 세계의 데이터를 필드로 기술된 데이터 타입과 이 데이터 타입들 간의 관계로 표현되는 논리적 구조의 데이터로 모델화
- 개념적 설계가 개념 스키마를 설계하는 단계라면, 논리적 설계에서는 개념 스키마를 평가 및 정재하고 DBMS에 따라 서로 다른 논리적 스키마를 설계하는 단계
- 트랜잭션의 인터페이스를 설계

## 물리적 설계(데이터 구조화)
- **논리적 구조료 표현된 데이터를 물리적 구조의 데이터로 변환하는 과정**
- 다양한 데이터베이스 응용에 대해 처리 성능을 얻기 위해 데이터베이스 파일의 저장 구조 및 액세스 경로를 결정
- 저장 레코드의 형식, 순서, 접근 경로, 조회 집중 레코드 등의 정보를 사용하여 데이터가 컴퓨터에 저장되는 방법 묘사

## 데이터베이스 구현
- **논리적 설계와 물리적 설계에서 도출된 데이터베이스 스키마를 파일로 생성하는 과정**
- 사용하려는 특정 DBMS의 DDL을 이용해 데이터베이스 스키마를 기술한 후 컴파일하여 빈 DB파일을 작성
- 응용 프로그램을 위한 트랜잭션 작성
- DB 접근을 위한 응용 프로그램 작성


# 031.데이터 모델의 개념

## 데이터 모델
- **현실 세계의 정보들을 컴퓨터에 표현하기 위해 단순화, 추상화하여 체계적으로 표현한 개념적 모형**
- 데이터, 데이터의 관계, 데이터의 의미 및 일관성, 제약 조건 등을 기술하기 위한 개념적 도구들로 구성되어 있다.
- 데이터베이스 설계 과정에서 데이터의 구조(스키마)를 논리적으로 표현하기 위해 지능적 도구로 사용됨
- 데이터 모델의 구성 요소 : 개체, 속성, 관계
- 데이터 모델 종류 : 개념적 데이터 모델, 논리적 데이터 모델, 물리적 데이터 모델
- 데이터 모델에 표시할 요소 : 구조, 연산, 제약 조건

## 개념적 데이터 모델
- **현실 세계에 대한 인간의 이해를 돕기 위해 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정**
- 속성으로 기술된 개체 타입과 이 개체 타입들 간의 관계를 이용해 현실 세계 표현
- 현실 세계에 존재하는 개체를 인간이 이해할 수 있는 정보 구조로 표현하기 때문에 정보 모델이라고도 함
- 대표적인 모델로는 E-R 모델이 있다.

## 논리적 데이터 모델
- **개념적 모델링 과정에서 얻은 개념적 구조를 컴퓨터가 이해하고 처리할 수 있는 컴퓨터 세계의 환경에 맞도록 변환하는 과정**
- 필드로 기술된 데이터 타입과 이 데이터 타입들 간의 관계를 이용해 현실 세계 표현
- 단순 데이터 모델은 논리적 데이터 모델을 의미
- 특정 DBMS는 특정 논리적 데이터 모델 하나만 선정해 사용
- 논리적 데이터 모델은 데이터 간의 관계를 어떻게 표현하느냐에 따라 관계 모델, 계층 모델, 네트워크 모델로 구분함

## 데이터 모델의 구성 요소
- 구조(Structure) : 논리적으로 표현된 개체 타입들 간의 관게로서 데이터 구조 및 정적 성질 표현
- 연산(Operation) : 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세로서 데이터베이스를 조작하는 기본 도구
- 제약 조건(Constraint) : 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건


# 032.데이터 모델의 구성 요소

## 개체(Entity)
- **데이터베이스에 표현하려는 것, 개념이나 정보단위같은 현실 세계의 대상체**
- 개체는 실세게에 독립적으로 존재하는 유형, 무형의 정보로서 서로 연관된 몇 개의 속성으로 구성됨
- 독립적으로 존재하거나 그 자체로서도 구별이 가능하며, 유일한 식별자에 의해 식별됨
- 다른 개체와 하나 이상의 관계가 있ㅇ다

## 개체의 구성 요소
- 속성 : 개체가 가지고 있는 특성
- 개체 타입 : 속성으로만 기술된 개체의 정의
- 개체 인스턴스 : 개체를 구성하고 있는 각 속성들이 값을 가져 하나의 개체를 나타내는 것
- 개체 세트 : 개체 인스턴스이 집합

## 속성(Attribute)
- **데이터베이스를 구성하는 가장 작은 논리적 단위**
- 파일 구조상의 데이터 항목 또는 데이터 필드에 해당
- 속성은 개체를 구성하는 항목으로 개체의 특성을 기술
- 속성의 수를 Degree 또는 차수라고 부름
- 속성은 속성의 특성과 개체 구성 방식에 따라 분류함

## 속성의 특성에 따른 분류
- 기본 속성(Basic)
  - 업무 분석을 통해 정의한 속성
  - 속성 중 가장 많고 일반적임
  - 업무로부터 분석한 속성이라도 업무상 코드로 정의한 속성은 기본 속성에서 제외됨
- 설계 속성(Designed)
  - 원래 업무상 존재하지 않고 설계 과정에서 도출해내는 속성
  - 업무에 필요한 데이터 외에 데이터 모델링을 위해 업무를 규칙화하려고 속성을 새로 만들거나 변형하여 정의하는 속성
- 파생 속성(Derived)
  - 다른 속성으로부터 계산이나 변형 등의 영향을 받아 발생하는 속성
  - 파생 속성은 되도록 적은 수를 정의하는 것이 좋음

## 속성의 개체 구분 방식에 따른 분류
- 기본키 속성 : 개체를 유일하게 식별할 수 있는 속성
- 외래키 속성 : 다른 개체와의 관계에서 포함된 속성
- 일반 속성 : 개체에 포함되어 있고 기본키, 외래키에 포함되지 않은 속성

## 관계(Relationship)
- **개체간의 논리적인 연결**
- 개체 간의 관계와 속성 간의 관계가 있다.

## 관계의 형태
 - 일 대 일( 1 : 1 )
 - 일 대 다( 1 : N )
 - 다 대 다( N : M )

## 관계의 종류
- 종속(Dependent) 관계
  - 두 개체 사이의 주종 관계 표현
  - 식별 관계와 비식별 관계가 있음
- 중복(Redundant) 관계
  - 두 개체 사이에 2번 이상의 종속 관계가 발생하는 관계
- 재귀 관계
  - 개체가 자기 자신과 관계를 갖는 것
  - 순환 관계라고도 함
- 베타 관계
  - 개체의 속성이나 구분자를 기준으로 개체의 특성을 분할하는 관계
  - 배타 AND 관계와 배타 OR 관계로 구분함


# 033.E-R(개체-관계, Entity-RelationShip) 모델

## E-R모델
- 개체와 개체 간의 관계를 기본 요소로 이용해 현실 세계의 무질서한 데이터를 개념적인 논리 데이터로 표현하기 위한 방법
- 1976년 피터 첸에 의해 제안되고 기본적인 구성요소가 정립되었음
- 개념적 데이터 모델의 가장 대표적인 것
- 데이터를 개체, 관계, 속성으로 묘사한다.
  - 개체 : 학생, 교수 ,자동차 등과 같이 실세계에서 개념적으로 또는 물리적으로 존재하는 실제 사용
  - 관계 : 교수 개체는 학생 개체를 지도하는 관계인 것처럼 다른 개체 타입에 속한 개체 사이의 관계 표현
  - 속성 : 학생의 이름, 주소 등과 같이 개체를 묘사하는 데 사용할 수 있는 특성 의미
- E-R다이어그램으로 표현하며, 관계 유형을 제한없이 나타낼 수 있다.

## E-R 다이어그램의 기호화 의미
- 사각형 : 개체 타입
- 마름모 : 관계 타입
- 타원 : 속성
- 이중 타원 : 다중값 속성(복합 속성)
- 밑줄 타원 : 기본키 속성
- 복수 타원 : 복합 속성(성명은 성과 이름으로 구성)
- 관계 : 개체 간 관계에 대한 대응수를 선 위에 기술
- 선(링크) : 개체 타입과 속성을 연결


# 034. 관계형 데이터베이스의 구조/관계형 데이터 모델

## 관계형 데이터베이스
- **2차원적인 표를 이용해 데이터 상호 관계를 정의하는 데이터베이스**
- 1970년 IBM에서 근무하던 코드(E.F.Codd)에 의해 처음 제안됨
- 개체와 관계를 모두 릴레이션(Relation)이라는 표로 표현하기 때문에 개체를 표현하는 개체 릴레이션과 관계를 표현하는 관계 릴레이션이 존재함
- 장점 : 간결하고 보기 편리하며, 다른 데이터베이스로의 변환이 용이함
- 단점 : 성능이 다소 떨어짐

## 관계형 데이터베이스의 릴레이션 구조
- 릴레이션은 데이터들을 표의 형태로 표현한 것으로, 구조를 나타내는 릴레이션 스키마와 실제 값들인 릴레이션 인스턴스로 구성됨
- [예시](https://www.google.com/url?sa=i&url=https%3A%2F%2Fppiyo5.tistory.com%2F11&psig=AOvVaw1SRSrq4kEsOKAph37q1ghy&ust=1679720656248000&source=images&cd=vfe&ved=0CBAQjRxqFwoTCIDw4Jnl8_0CFQAAAAAdAAAAABAE)

## 튜플(Tuple)
- **릴레이션을 구성하는 각각의 행**
- 튜플은 속성의 모임으로 구성되며 파일 구조에서는 레코드와 같은 의미
- 튜플의 수를 카디널리티(Cardinality), 또는 기수, 대응수라고도 함

## 속성(Attribute)
- **데이터베이스를 구성하는 가장 작은 논리적 단위**
- 파일 구조상의 데이터 항목 또는 데이터 필드에 해당
- 개체의 특성을 기술하며, 속성의 수를 디그리(Degree)또는 차수라고 함

## 도메인(Domain)
- **하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자값들의 집합**
- 실제 애트리뷰트 값이 나타날 때 그 값의 합법 여부를 시스템이 검사하는데도 이용됨

## 릴레이션의 특징
- 한 릴레이션에는 똑같은 튜플이 포함될 수 없으므로 릴레이션에 포함된 튜플들은 모두 상이하다
- 한 릴레이션에 포함된 튜플 사이에는 순서가 없다
- 튜플들의 삽입, 삭제 등의 작업으로 인해 릴레이션은 시간에 따라 변한다
- 릴레이션 스키마를 구성하는 속성들 간의 순서는 중요하지 않다
- 속성의 유일한 식별을 위해 속성의 명칭은 유일해야 하지만, 속성을 구성하는 값은 동일한 값이 있을 수 있다
- 릴레이션을 구성하는 튜플을 유일하게 식별하기 위해 속성들의 부분집합을 키로 설정한다
- 속성의 값은 논리적으로 더 이상 쪼갤 수 없는 원자값만을 저장한다

## 관계형 데이터 모델(Relational Data Model)
- **2차원적인 표를 이용해 데이터 상효 관계를 정의하는 DB구조**
- 가장 널리 사용되는 데이터 모델
- 파일 구조처럼 구성한 테이블들을 하나의 DB로 묶어서 테이블 내에 있는 속성들 간의 관계(Relationship)를 설정하거나 테이블 간의 관계를 설정하여 이용
- 기본키와 이를 참조하는 외래키로 데이터간의 관계 표현
- 계층 모델과 망 모델의 복잡한 구조를 단순화시킨 모델
- 관계형 모델의 대표적인 언어는 SQL이다
- 1:1, 1:N, N:M 관계를 자유롭게 표현할 수 있다


# 035.관계형 데이터베이스의 제약 조건-키

## 키(Key)
- **데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 기준이 되는 속성**
- 키의 종류 : 후보키, 기본키, 대체키, 슈퍼키, 외래키

## 후보키(Candidate Key)
- **속성들 중에서 튜플을 유일하게 식별하기 위해 사용되는 속성들의 부분집합**
- 기본키로 사용할 수 있는 속성들
- 유일성과 최소성을 모두 만족시켜야함
  - 유일성 : 하나의 키 값으로 하나의 튜플만을 유일하게 식별할 수 있어야 함
  - 최소성 : 키를 구성하는 속성 하나를 제고하면 유일하게 식별할 수 없도록 꼭 필요한 최소의 속성으로 구성해야 함

## 기본키(Primary Key)
- **후보키 중에서 특별히 선정된 주키**
- 중복된 값을 가질 수 없어 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성
- 기본키는 NULL값을 가질 수 없다. 즉 튜플에서 기본키로 설정된 속성에는 NULL값이 있어서는 안 된다.

## 대체키(Alternate Key)
- **후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키**
- 보조키라고도 부름

## 슈퍼키(Super Key)
- **속성들의 집합으로 구성된 키**
- 릴레이션을 구성하는 모든 튜플 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타나지 않는다
- 슈퍼키는 유일성은 만족하지만 최소성은 만족하지 못한다.

## 외래키(Foreign Key)
- **다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합**
- 외래키로 지정되며 참조 릴레이션의 기본키에 없는 값은 입력할 수 없다


# 036.관계형 데이터베이스의 제약 조건-무결성

## 무결성(Integrity)
- **데이터베이스에 저장된 데이터 값과 현실 세계의 실제값이 일치하는 정확성을 의미**
- 무결성 제약 조건은 DB에 들어있는 데이터의 정확성을 보장하기 위해 부정확한 자료가 DB내에 저장되는 것을 방지하기 위한 제약조건

## 무결성의 종류
- 개체 무결성 : 기본 테이블의 기본키를 구성하는 어떤 속성도 Null값이나 중복값을 가질 수 없다
- 참조 무결성 : 외래키 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 한다. 즉 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다
- 도메인 무결성 : 주어진 속성 값이 정의된 도메인에 속한 값이어야 한다
- 사용자 정의 무결성 : 속성 값들이 사용자가 정의한 제약조건에 만족되어야 한다
- NULL 무결성 : 릴레이션의 특정 속성 값이 NULL이 될 수 없도록 함
- 고유 무결성 : 릴레이션의 특정 속성에 대해 각 튜플이 갖는 속성값들이 서로 달라야 한다는 규정
- 키 무결성 : 하나의 릴레이션에는 적어도 하나의 키가 존재해야 한다
- 관계 무결성 : 릴레이션에 어느 한 튜플의 삽입 가능 여부 또는 한 릴레이션과 다른 릴레이션의 튜플들 사이의 관계에 대한 적절성 여부를 지정한 규정

## 데이터 무결성 강화
- 데이터 무결성은 데이터 품질에 직접적인 영향을 미치므로 데이터 특성에 맞는 적절한 무결성을 정의하고 강화해야 한다
- 애플리케이션, 데이터베이스 트리거, 제약조건을 이용해 강화할 수 있다.
  - 애플리케이션 : 데이터 생성, 수정, 삭제 시 무결성 조건을 검증하는 코드를 프로그램 내에 추가
  - 데이터베이스 트리거 : 트리거 이벤트에 무결성 조건을 실행하는 절차형 SQL 추가
  - 데이터베이스에 제약조건을 설정하여 무결성 유지


# 037.관계대수 및 관계해석

## 관계대수
- 관계형 데이터베이스에서 **원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절차적인 언어**
- 릴레이션을 처리하기 위해 연산자와 연산규칙을 제공하며, 피연산자와 연산 결과가 모두 릴레이션임
- 질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시함
- 관계 데이터베이스에 적용하기 위해 특별히 개발한 순수 관계 연산자와 수학적 집합 이론에서 사용하는 일반 집합 연산자가 있음

## 순수 관계 연산자
- Select(σ, 시그마)
  - 릴레이션에 존재하는 튜플 중에서 선택 조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만드는 연산
  - 릴레이션의 행에 해당하는 튜플을 구하는 것이므로 수평 연산이라고도 함
- Project(π, 파이)
  - 주어진 릴레이션에서 속성 리스트에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 연산
  - 연산 결과에 중복이 발생하면 중복이 제거됨
  - 릴레이션의 열에 해당하는 속성을 추출하는 것이므로 수직 연산자라고도 함
- Join(⋈)
  - 공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 영상
  - Join의 결과는 교차곱을 수행한 다음 Select를 수행하는 것과 같음
- Division(÷)
  - X⊃Y인 두 개의 릴레이션 R(X)와 S(Y)가 있을 때, R의 속성이 S의 속성값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산

## 일반 집합 연산자
- **수학적 집합 이론에서 사용하는 연산자**
- 합집합, 교집합, 차집합을 처리하기 위해서는 합병 조건을 만족해야 한다.
  - 합병 조건은 합병하려는 두 릴레이션 간에 속성의 수가 같고, 대응되는 속성별로 도메인이 같아야 한다.
- 합집합(Union ∪)
  - 두 릴레이션에 존재하는 튜플의 합집합을 구하되, 결과로 생성된 릴레이션에서 중복되는 튜플은 제거되는 연산
  - 합집합의 카디널리티는 두 릴레이션 카디널리티의 합보다 작거나 같다
- 교집합(Intersection ∩)
  - 두 릴레이션 A와 B에 존재하는 튜플의 교집합을 구하는 연산, A와 B에 동시에 존재하는 튜플만 결과에 출력된다.
  - 교집합의 카디널리티는 두 릴레이션 중 카디널리티가 적은 릴레이션의 카디널리티보다 작거나 같다
- 차집합(Difference -)
  - 두 릴레이션 A와 B에존재하는 튜플의 차집합을 구하는 연산, A에는 존재하지만 B에는 존재하지 않는 튜플만 결과에 출력된다.
  - 차집합의 카디널리티는 릴레이션 A의 카디널리티보다 작거나 같다.
- 교차곱(Cartesian product ×)
  - 두 릴레이션에 있는 튜플들의 순서쌍을 구하는 연산
  - 교차곱의 디그리는 두 릴레이션의 디그리를 더한 것과 같고, 카디널리티는 두 릴레이션의 카디널리티를 곱한 것과 같다.

## 관계해석(Relation Calculus)
- **관계 데이터의 연산을 표현하는 방법**
- 제안자인 코드가 수학의 술어 해석에 기반을 두고 관계 데이터베이스를 위해 제안했다
- 원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성을 지님
- 원하는 정보를 정의할 때는 계산 수식 사용


# 038.이상 / 함수적 종속

## 이상(Anomaly)
- **테이블에서 일부 속성들의 종속으로 인해 데이터의 중복이 발생하고, 이 중복(Redundancy)으로 인해 테이블 조작 시 문제가 발생하는 현상을 의미**
- 이상의 종류는 다음과 같다.
  - 삽입 이상(Insertion Anomaly) : 테이블에 데이터를 삽입할 때 의도와는 상관없이 원하지 않는 값들로 인해 삽입할 수 없게 되는 현상
  - 삭제 이상(Deletion Anomaly) : 테이블에서 한 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는 현상
  - 갱신 이상(Update Anomaly) : 테이플에서 튜플에 있는 속성 값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 불일치성이 생기는 현상

## 함수적 종속(Functional Dependency)
- 어떤 테이블 R에서 X와 Y를 각각 R의 속성집합의 부분집합이라 할 대, 속성 X의 값 각각에 대해 시간에 관계없이 항상 속성 Y의 값이 오직 하나만 연관되어 있을 때 Y는 X에 함수적 종속 또는 X가 Y를 함수적으로 결정한다고 하고, X->Y로 표기한다.
  - ex) <U>학번</U>, 이름, 학년, 학과 속성이 있을 때 이름, 학년, 학과는 각각 학번 속성에 함수적 종속이다. 이를 '학번 -> 이름, 학년, 학과'로 표현할 수 있다.
- 함수적 종속은 데이터의 의미를 표현하는 것으로, 현실 세계를 표현하는 제약 조건이 되는 동시에 데이터베이스에서 항상 유지되어야 할 조건이다.
- X -> Y의 관계를 갖는 속성 X와 Y에서 X를 결정자(Determinant)라 하고, Y를 종속자(Dependent)라고 한다. 예를 들어 '학번 -> 이름'에서는 학번이 결정자이고 이름이 종속자이다.

## 완전 함수적/부분 함수적/이행적 함수적 종속
- 완전 함수적 종속 : 어떤 테이블 R에서 속성 Y가 다른 속성 집합 X 전체에 대해 함수적 종속이면서 속성 집합 X의 어떠한 진부분 집합(Z ⊂ X)에도 함수적 종속이 아닐 때 속성 Y는 속성 집합 X에 완전 함수적 종속이다
- 부분 함수적 종속 : 어떤 테이블 R에서 속성 Y가 다른 속성 집합 X 전체에 대해 함수적 종속이면서 속성 집합 X의 임의의 진부분 집합에 대해 함수적 종속일 때 속성 Y는 속성 집합 X에 부분 함수적 종속이다
- 완전 함수적 종속이라는 말은 어떤 속성이 기본키에 대해 완전히 종속적일 때를 말한다. 예를 들어 <수강> 테이블은 (학번, 과목번호)가 기본키인데, 성적은 학벙과 과목번호가 같을 경우에는 항상 같은 성적이 오므로, 즉 성적은 학번과 과목번호에 의해서만 결정되므로 성적은 기본키에 완전 함수적 종속이다. 반면 학년은 과목번호에 관계없이 학번이 같으면 항상 같으므로, 즉 기본키의 일부인 학번에 의해서 학년이 결정되므로 학년은 부분 함수적 종속이다.
- 이행적 함수적 종속 : X -> Y이고 Y -> Z일 때 X -> Z를 만족하는 관계를 이행적 함수적 종속이라고 한다.


# 039.정규화

## 정규화(Normalization)
- **테이블의 속성들이 상호 종속적인 관계를 갖는 특성을 이용해 테이블을 무손실 분해하는 과정**
  - 테이블 R의 프로젝션(특정 테이블에서 일부 속성들만 추출하여 만든 테이블)인 R1, R2가 내추럴 조인을(두 테이블의 동일한 이름(컬럼명)을 갖는 컬럼은 모두 조인이 됨)통해 원래의 테이블 R로 정보 손실 없이 복귀되는 경우 R은 R1과 R2로 무손실 분해되었다고 한다.
- 정규화의 목적은 가능한 한 중복을 제거하여 삽입, 삭제, 갱신 이상의 발생 가능성을 줄이는 것이다.
- 정규화는 제 1/2/3/4/5 정규형이 있으며 순서대로 정규화의 정도가 높아진다.

## 정규화 과정
- 제 1정규형
  - 제 1정규형은 테이블 R에 속한 모든 속성의 도메인이 원자 값으로만 되어 있는 정규형이다. 즉 하나의 속성에는 하나의 값만이 들어가야 한다.
  - ex) <주문목록>테이블에서 반복되는 주문 관련 정보인 주문번호, 고객번호, 주소, 주문수량을 분리하여 <U>제품번호</U>, 제품명, 재고수량을 속성으로 갖는 <제품>테이블과 <U>주문번호</U>, <U>제품번호</U>, 고객번호, 주소, 주문수량을 속성으로 갖는 <제품주문>테이블을 만든다
- 제 2정규형
  - 제 2정규형은 테이블 R이 제 1정규형이고, 기본키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속을 만족하는 주문이다.
  - ex) <제품주문>테이블에서 고객번호와 주소는 기본키(주문번호, 제품번호)가 아닌 주문번호에 의해서도 결정될 수 있기 때문에 <U>주문번호</U>, <U>제품번호</U>, 주문수량을 속성으로 갖는 <주문목록>테이블과 <U>주문번호</U>, 고객번호, 주소를 속성으로 갖는 <주문>테이블로 나눈다
- 제 3정규형
  - 제 3정규형은 테이블 R이 제 2정규형이고, 기본키가 아닌 모든 속성이 기본키에 대해 이행적 함수적 종속을 만족하지 않는 정수형이다.
  - ex) <주문>테이블에서 고객번호가 주문번호에 함수적 종속이고, 주소가 고객번호에 함수적 종속이므로(주문번호 -> 고객번호, 고객번호 -> 주소이므로 주문번호 -> 주소를 만족하므로) 주소는 기본키인 주문번호에 대해 이행적 함수적 종속을 만족한다. 따라서 <U>주문번호</U>, 고객번호를 갖는 <주문>테이블과 <U>고객번호</U>, 주소를 갖는 <고객>테이블로 나눈다
- BCNF
  - BCNF는 테이블 R에서 모든 결정자가 후보키인 정규형이다.
  - 일반적으로 제 3정규형에 후보키가 여러 개 존재하고, 이러한 후보키들이 서로 중첩되어 나타나는 경우에 적용 가능하다
  - ex) <U>학번</U>, <U>과목명</U>, 담당교수로 이뤄진 <수강교수>테이블에서 담당교수 -> 과목명이지만 담당교수는 후보키가 아니기 때문에 BCNF를 만족시키지 않으므로 <U>학번</U>, <U>담당교수</U>로 이루어진 <수강>테이블과 <U>담당교수</U>, 과목명으로 이루어진 <교수>테이블로 분리한다.
- 제 4정규형
  - 제 4정규형은 테이블 R에 다중 값 종속(A ->-> B)가 존재할 경우 R의 모든 속성이 A에 함수적 종속 관계를 만족하는 정규형이다
  - 다중 값 종속(다치종속) : A, B, C 3개의 속성을 가진 테이블 R에서 어떤 복합 속성(A, C)에 대응하는 B값의 집합이 A값에만 종속되고 C값에는 무관하면, B는 A에 다중 값 종속이라 하고 A ->-> B로 표기한다.
- 제 5정규형
  - 제 5정규형은 테이블 R의 모든 조인 종속이 R의 후보키를 통해서만 성립되는 정규형이다
  - 조인 종속 : 어떤 테이블 R의 속성에 대한 부분집합 X, Y, ..., Z가 있다고 하자. 이 때 만일 테이블 R이 자신의 프로젝션 X, Y, ..., Z를 모두 조인한 결과와 동일한 경우 테이블 R은 조인 종속 JD(X, Y, ..., Z)를 만족한다고 한다.


# 040.반정규화

## 반정규화(비정규화, Denormalization)
- 시스템 성능의 향상, 개발 및 운영의 편의성 등을 높이기 위해 **정규화된 데이터 모델을 의도적으로 통합, 중복, 분리하여 정규화 원칙을 위배하는 행위**
- 반정규화를 수행하면 시스템의 성능이 향상되고 관리 효율성은 증가하지만 데이터의 일관성 및 정합성이 저하될 수 있다.
- 과도한 반정규화는 오히려 성능을 저하시킬 수 있다.
- 반정규화의 방법
  - 테이블 통합, 테이블 분할, 중복 테이블 추가, 중복 속성 추가

## 테이블 통합
- 두 개의 테이블이 조인되어 사용되는 경우가 많을 경우 성능 향상을 위해 하나의 테이블로 만들어 사용하는 것
- 테이블 통합을 고려하는 경우
  - 두 개의 테이블에서 발생하는 프로세스가 동일하게 자주 처리되는 경우
  - 항상 두 개의 테이블을 이용하여 조회를 수행하는 경우
- 테이블 통합의 종류
  - 1:1관계 테이블 통합
  - 1:N관계 테이블 통합
  - 슈퍼타입/서브타입 테이블 통합

## 테이블 분할
- 테이블 분할은 테이블을 수직 또는 수평으로 분할하는 것
- 수평 분할
  - 레코드를 기준으로 테이블을 분할
  - 레코드별로 사용 빈도의 차이가 큰 경우 사용 빈도에 따라 테이블 분할
- 수직 분할
  - 하나의 테이블에 속성이 너무 많을 경우 속성을 기준으로 테이블 분할
  - 종류 : 갱신 위주의 속성/자주 조회되는 속성/크기가 큰 속성/보안을 적용해야 하는 속성 분할

## 중복 테이블 추가
- 작업의 효율성을 향상시키기 위해 테이블을 추가하는 것
- 중복 테이블을 추가하는 경우
  - 여러 테이블에서 데이터를 추출해서 사용해야 할 경우
  - 다른 서버에 저장된 테이블을 이용해야 하는 경우
- 중복 테이블 추가 방법
  - 집계 테이블의 추가 : 집게 데이터를 이용한 테이블을 생성하고 각 원본 테이블에 트리거를 설정해 사용하는 것
  - 진행 테이블의 추가 : 이려 관리 등의 목적으로 추가하는 테이블
  - 특정 부분만을 포함하는 테이블 추가 : 데이터가 많은 테이블의 특정 부분만을 사용하는 경우 해당 부분만으로 새로운 테이블을 생성

## 중복 속성 추가
- 조인해서 데이터를 처리할 때 데이터를 조회하는 경로를 단축하기 위해 자주 사용하는 속성을 하나 더 추가
- 중복 속성 추가시 데이터의 무결성 확보가 어렵고 디스크 공간이 추가로 필요
- 중복 속성을 추가하는 경우
  - 조인이 자주 발생하는 속성인 경우
  - 접근 경로가 복잡한 속성인 경우
  - 액세스의 조건으로 자주 사용되는 경우
  - 기본키의 형태가 적절치 않거나 여러 개의 속성으로 구성된 경우


# 041.시스템 카탈로그

## 시스템 카탈로고(System Catalog)
- 시스템 그 자체에 관련이 있는 **다양한 객체에 관한 정보를 포함하는 시스템 DB**
- 시스템 카탈로그 내의 각 테이블은 사용자를 포함하여 DBMS에서 지원하는 모든 데이터 객체에 대한 정의나 명세에 관한 정보를 유지 관리하는 시스템 테이블
- 카탈로그들이 생성되면 데이터 사전에 저장되기 때문에 좁은 의미로는 카탈로그를 데이터 사전이라고도 함

## 메타데이터(Meta-Data)
- **시스템 카탈로그에 저장된 정보**
- 메타 데이터의 유형
  - DB객체정보 : 테이블, 인덱스, 뷰 등의 구조 및 통계 정보
  - 사용자 정보 : 아이디어, 패스워드, 접근 권한 등
  - 테이블의 무결성 제약 조건 정보 : 기본키, 왜래키, 널값 허용 여부 등
  - 함수, 프로시저, 트리거 등에 대한 정보

## 데이터 디렉토리(data Directory)
- **데이터 사전에 수록된 데이터에 접근하는 데 필요한 정보를 관리 유지하는 시스템**
- 시스템 카탈로그는 사용자와 시스템 모두 접근할 수 있지만 디렉터리는 시스템만 접근 가능


# 042.트랜잭션 분석/CRUD 분석

## 트랜잭션(Transaction)
- DB의 상태를 변환시키는 하나의 **논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 하는 일련의 연산**
- DB시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위
- 사용자가 시스템에 대한 서비스 요구시 시스템이 응답하기 위한 상태 변환 과정의 작업 단위로 사용됨

## 트랜잭션의 특징
- 원자성(Atomicy) : 트랜잭션의 연산은 데이터베이스에 모두 반영되도록 완료(Commit)되든지 아니면 전혀 반영되지 않도록 복구(Rollback)되어야 함
- 일관성(Consistency) : 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환함
- 독립성(Isolation) : 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없음
- 영속성(Durability) : 성공적으로 완려된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 함

## CRUD분석
- CRUD는 테이블에 변화를 주는 트랜잭션의 연산, 즉 생성(Create), 읽기(Read), 갱신(Update), 삭제(Delete)의 앞 글자만 모아 만든 용어
- **프로세스와 테이블 간에 CRUD매트릭스를 만들어 트랜잭션을 분석하는 것**
- CRUD분석을 통해 많은 트랜잭션이 몰리는 테이블을 파악할 수 있으므로 디스크 구성 시 유용한 자료로 활용할 수 있다.

## CRUD매트릭스
- 2차원 형태의 표로서, 행(세로열)에는 프로세스를, 열(가로열)에는 테이블을, 행과 열이 만나는 위치에는 프로세스가 테이블에 발생시키는 변화를 표시하여 프로세스와 데이터 간의 관계를 분석하는 분석표이다.
- CRUD매트릭스를 통해 트랜잭션이 테이블에 수행하는 작업을 검증한다.
- CRUD매트릭스의 각 셀에는 Create, Read, Update, Delete의 앞 글자가 들어가며, 복수의 변화를 줄 때에는 기본적으로 'C > D > U > R'의 우선순위를 적용하여 한 가지만 적지만, 활용 목적에 따라 모두 기록할 수 있다.
- CRUD매트릭스가 완성되었다면 아무 것도 적히지 않은 행이나 열, C나 R이 없는 열을 확인하여 불필요하거나 누락된 테이블 또는 프로세스를 찾는다.

## 트랜잭션 분석
- 트랜잭션 분석은 CRUD 매트릭스를 기반으로 테이블에 발생하는 트랜잭션 양을 분석하여 테이블에 저장되는 데이터의 양을 유추하고 이를 근거로 DB의 용량 산정 및 구조의 최적화를 목적으로 한다.
- 트랜잭션 분석은 업무 개발 담당자가 수행한다.
- 트랜잭션 분석을 통해 프로세스가 과도하게 접근하는 테이블을 확인할 수 있으며, 이러한 집중 접근 테이블을 여러 디스크에 분산 배치함으로써 디스크 입출력 향상을 통한 성능 향상을 가져올 수 있다.
- 트랜잭션 분석시
  - 단위 프로세스와 CRUD매트릭스를 이용하여 작성한다.
  - 구성 요소 : 단위 프로세스, CRUD연산, 테이블명, 컬럼명, 테이블 참조 횟수. 트랜잭션 수, 발생 주기 등


# 043.인덱스

## 인덱스(Index)
- **데이터 레코드를 빠르게 접근하기 위해 <키 값, 포인터>쌍으로 구성되는 데이터 구조**
- 레코드가 저장된 물리적 구조에 접근하는 방법 제공
- 인덱스를 통해 파일의 레코드에 빠르게 액세스 가능
- 레코드의 삽입과 삭제가 수시로 일어나는 경우에는 인덱스의 개수를 최소로 하는 것이 효율적

## 인덱스의 종류
- 트리 기반 인덱스 : 인덱스를 저장하는 블록들이 트리 구조를 이루고 있는 것
- 비트맵 인덱스 : 인덱스 컬럼의 데이터를 비트값이 0 또는 1로 변환하여 인덱스 키로 사용하는 방법
- 함수 기반 인덱스 : 컬럼의 값 대신 컬럼에 특정 함수나 수식을 적용하여 산출된 값을 사용하는 것
- 비트맵 조인 인덱스 : 다수의 조인된 객체로 구성된 인덱스
- 도메인 인덱스 : 개발자가 필요한 인덱스를 직접 만들어 사용하는 것

## 클러스티드/넌클러스티드 인덱스
- 클러스티드 인덱스
  - 인덱스 키의 순서에 따라 데이터가 정렬되어 저장되는 방식
  - 실제 데이터가 순서대로 저장되어 있어 인덱스를 검색하지 않아도 원하는 데이터를 빠르게 찾을 수 있음
- 넌클러스터드 인덱스
  - 인덱스의 키 값만 정렬되어 있고 실제 데이터는 정렬되지 않는 방식
  - 데이터 삽입, 삭제 발생 시 순서를 유지하기 위해 데이터를 재정렬해야 함


# 044.뷰/클러스터

## 뷰(View)
- **하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 가상 테이블**
- 저장장치 내에 물리적으로 존재하지 않지만 사용자에게 있는 것처럼 간주됨
- 뷰를 통해서만 데이터에 접근하게 하면 뷰에 나타나지 않는 데이터를 안전하게 보호하는 효율적인 기법으로 사용할 수 있다.
- 뷰가 정의된 기본 테이블이나 뷰를 삭제하면 그 테이블이나 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제됨
- 뷰를 정의할 때에는 CREATE문, 제거할 때는 DROP문 사용

## 뷰의 장단점
- 장점
  - 논리적 데이터 독립성 제공
  - 동일 데이터에 대해 동시에 여러 사용자의 상이한 응용이나 요구 지원
  - 사용자의 데이터 관리를 간단하게 해줌
  - 접근 제어를 통한 자동 보안이 제공됨
- 단점
  - 독립적인 인덱스를 가질 수 없음
  - 뷰의 정의를 변경할 수 없음
  - 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신 연산에 제약이 따름

## 클러스터(Cluster)
- 데이터 저장 시 데이터 엑세스 효율을 향상시키기 위해 **동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법**
- 클러스터링 된 테이블은 데이터 조회 속도를 향상시키지만 입력, 수정, 삭제에 대한 작업 성능을 저하시킴
- 데이터의 분포도가 넓을수록 유리하며, 데이터 분포도가 넓은 테이블을 클러스터링 하면 저장 공간 절약 가능
- 처리 범위가 넓은 경우에는 단일 테이블 클러스터링을, 조인이 많이 발생하는 경우에는 다중 테이블 클러스터링 사용


# 045.파티션

## 파티션(Partition)
- **대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것**
- 대용량 DB의 경우 몇 개의 중요한 테이블에만 집중되어 데이터가 증가되므로, 이러 테이블들을 작은 단위로 나눠 분산시키면 성능 저하를 방지할 뿐만 아니라 데이터 관리도 쉬워짐
- 데이터 처리는 테이블 단위로 이뤄지고 데이터 저장은 파티션별로 수행

## 파티션의 장단점
- 장점
  - 데이터 접근 시 액세스 범위를 줄여 쿼리 성능 향상
  - 파티션별로 데이터가 분산되어 저장되므로 디스크 성능 향상
  - 파티션별로 백업 및 복구를 수행하므로 속도가 빠름
  - 시스템 장애 시 데이터 손상 정도 최소화 가능
  - 데이터 가용성 향상
  - 파티션 단위로 입/출력 분산 가능
- 단점
  - 하나의 테이블을 세분화하여 관리하므로 세심한 관리 요구
  - 테이블간 조인에 대한 비용 증가
  - 용량이 적은 테이블에 파티셔닝을 수행하면 오히려 성능 저하

## 파티션의 종류
- 범위 분할(Range Partitioning)
  - 지정한 열의 값을 기준으로 분할 (ex) 일별, 월별, 분기별 등)
- 해시 분할(Hash Partitioning)
  - 해시 함수를 적용한 결과 값에 따라 데이터 분할
  - 특정 파티션에 데이터가 집중되는 범위 분할의 단점을 보완한 것으로, 데이터를 고르게 분산할 때 유리
  - 특정 데이터가 어디에 있는지 판단 불가능
  - 고객번호, 주민번호 등과 같이 데이터가 고른 컬럼에 효과적
- 조합 분할(Composite Partitioning)
  - 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할하는 방식
  - 범위 분할한 파티션이 너무 커 관리가 어려울 때 유용


# 046.분산 데이터베이스 설계

## 데이터베이스 용량 설계
- 데이터가 저장될 공간을 정의하는 것
- 테이블에 저장될 데이터양과 인덱스, 클러스터 등이 차지하는 공간 등을 예측하여 반영해야 함
- 데이터베이스 용량 설계의 목적
  - DB의 용량을 정확히 산정하여 디스크의 저장 공간을 효과적으로 사용하고 확장성 및 가용성을 높임
  - 디스크의 특성을 고려하여 설계함으로써 디스크의 입출력 부하를 분산시키고 채널 병목 현상 최소화

## 분산 데이터베이스 설계
- **논리적으로는 하나의 시스템에 속하지만 물리적으로는 네트워크를 통해 연결된 여러 개의 사이트에 분산된 데이터베이스**
- 데이터의 처리나 이용이 많은 지역에 데이터베이스를 위치시킴으로써 데이터의 처리가 가능한 해당 지역에서 해결될 수 있도록 한다
- 애플리케이션이나 사용자가 분산되어 저장된 데이터에 접근하는 것을 목표로 한다

## 분산 데이터베이스의 목표
- 위치 투명성(Location Transparancy) : 액세스하려는 데이터베이스의 실제 위치를 알 필요 없이 단지 데이터베이스의 논리적 명칭만으로 액세스할 수 있다
- 중복 투명성(Replication Transparancy) : 동일 데이터가 여러 곳에 중복되어 있더라도 사용자는 마치 하나의 데이터만 존재하는 것처럼 사용하고, 시스템은 자동으로 여러 자료에 대한 작업을 수행
- 병행 투명성(Concurrency Transparancy) : 분산 데이터베이스와 관련된 다수의 트랜잭션들이 동시에 실행되더라도 그 트랜잭션의 결과는 영향을 받지 않음
- 장애 투명성(Failure Transparancy) : 트랜잭션, DBMS, 네트워크, 컴퓨터 장애에도 불구하고 트랜잭션을 정확하게 처리

## 분산 설계 방법
- 테이블 위치 분산
  - 데이터베이스의 테이블을 각기 다른 서버에 분산시켜 배치하는 방법
- 분할
  - 테이블의 데이터를 분할하여 분산시키는 것
  - 분할 규칙 : 완전성, 재구성, 상호 중첩 배제
  - 주요 분할 방법
    - 수평 분할 : 특정 속성의 값을 기준으로 행 단위로 분할
    - 수직 분할 : 데이터 컬럼 단위로 분할
- 할당
  - 동일한 분할을 여러 개의 서버에 생성하는 분산 방법
  - 중복이 없는 할당과 중복이 있는 할당으로 나뉨


# 047.데이터베이스 이중화 / 서버 클러스터링

## 데이터베이스 이중화(Datapase Replication)
- 시스템 오류로 인한 데이터베이스 서비스 중단이나 물리적 손상 발생시 이를 복구하기 위해 **동일한 데이터베이스를 복제하여 관리하는 것**
- 이중화 수행 시 하나 이상의 데이터베이스가 항상 같은 상태를 유지하므로 데이터베이스에 문제가 발생하면 복제된 데이터베이스를 이용하여 즉시 문제 해결 가능
- 여러 개의 데이터베이스를 동시에 관리하므로 사용자가 수행하는 작업은 데이터베이스 이중화 시스템에 연결된 다른 데이터베이스에도 동일하게 적용됨
- 애플리케이션을 여러 개의 데이터베이스에서 분산 처리하므로 데이터베이스의 부하를 줄일 수 있음
- 데이터베이스 이중화를 이용하면 손쉽게 백업 서버 운영 가능

## 데이터베이스 이중화의 분류
- Eager 기법
  - 트랜잭션 수행 중 데이터 변경 발생 시 이중화된 모든 데이터베이스에 즉시 전달해 변경 내용이 즉시 적용되는 기법
- Lazy 기법
  - 트랜잭션의 수행이 종료되면 변경 사실을 새로운 트랜잭션에 작성해 각 데이터베이스에 전달되는 기법
  - 데이터베이스마다 새로운 트랜잭션이 수행되는 것으로 간주됨

## 데이터베이스 이중화 구성 방법
- 활동-대기 방법
  - 한 DB가 활성 상태로 서비스하고 있으면 다른 DB는 대기하고 있다가 활성 DB에 장애가 발생하면 대기 상태에 있던 DB가 자동으로 모든 서비스를 대신 수행
  - 구성 방법과 관리가 쉬워 많은 기업에서 이용
- 활동-활동 방법
  - 두 개의 DB가 서로 다른 서비스를 제공하다가 둘 중 한쪽에 문제가 발생하면 나머지 다른 DB가 서비스 제공
  - 두 DB가 모두 처리를 하기 때문에 처리율이 높지만 구성 방법 및 설정이 복잡

## 클러스터링(Clustering)
- **두 대 이상의 서버를 하나의 서버처럼 운영하는 기술**
- 서버 이중화 및 공유 스토리지를 사용하여 서버의 고가용성 제공

## 클러스터링의 종류
- 고가용성 클러스터링
  - 하나의 서버에 장애가 발생하면 다른 서버가 받아 처리하여 서비스 중단을 방지하는 방식
  - 일반적으로 언급되는 클러스터링
- 병렬 처리 클러스터링
  - 전체 처리율을 높이기 위해 하나의 작업을 여러 개의 서버에서 분산하여 처리하는 방식

## RTO/RPO
- RTO(Recovery Time Objective, 목표 복구 시간)
  - 비상사태 또는 업무 중단 시점으로부터 복구되어 가동될 때까지의 소요 시간을 의미
- RPO(Recovery Point Objective, 목표 복구 시점)
  - 비상사태 또는 업무 중단 시점으로부터 데이터를 복구할 수 있는 기준점을 의미


# 048.데이터베이스 보안

## 데이터베이스 보안
- 데이터베이스의 일부 또는 전체에 대해 권한이 없는 사용자가 액세스하는 것을 금지하기 위해 사용되는 기술
- 보안을 위해 데이터 단위는 테이블 전체로부터 특정 테이블의 특정 행과 열에 있는 데이터 값에 이르기까지 다양함

## 암호화(Encryption)
- 데이터를 보낼 때 송신자가 지정한 수신자 이외에는 그 내용을 알 수 없도록 평문을 암호문으로 변화는 것
- 암호화 과정은 평문을 암호문으로, 복호화 과정은 암호문을 원래의 평문으로 바꾸는 과정
- 암호화 기법은 개인키/공개키 암호 방식이 있음

## 접근통제
- 접근톤제는 데이터가 저장된 객체와 이를 사용하려는 주체 사이의 정보흐름을 제한하는 것
- 접근통제 3요소 : 정책, 매커니즘, 보안모델
- 접근 통제 기술
  - 임의 접근통제(DAC, Discretionary Access Control)
    - 데이터에 접근하는 사용자의 신원에 따라 접근 권한을 부여하는 방식
    - 데이터 소유자가 접근통제 권한을 지정하고 제어함
    - 객체를 생성한 사용자가 생성된 객체에 대한 모든 권한을 부여받고, 부여된 권한을 다른 사용자에게 허가할 수도 있음
  - 강제 접근통제(MAC, Mandatory Access Control)
    - 주체와 객체의 등급을 비교하여 접근 권한을 부여하는 방식
    - 시스템이 접근통제 권한을 지정
    - 데이터베이스 객체별로 보안 등급을 부여할 수 있음
    - 사용자별로 인가 등급을 부여할 수 있음
  - 역할기반 접근통제 (RBAC, Role Based Access Control)
    - 사용자의 역할에 따라 접근 권한을 부여하는 방식
    - 중앙관리자가 접근통제 권한을 지정함
    - 임의 접근통제와 강제 접근통제의 단점 보완
    - 다중 프로그래밍 환경에 최적화된 방식

## 접근통제 정책
- 접근통제 정책은 어떤 주체가 언제 어디서 어떤 객체에게 어떤 행위에 대한 허용 여부를 정의하는 것
- 접근통제 정책의 종류
  - 신분 기반 정책
    - 주체나 그룹의 신분에 근거하여 객체의 접근을 제한하는 방법으로 IBP와 GBP가 있음
    - IBP(Individual-Based Policy) : 최소 권한 정책으로, 단일 주체에게 하나의 객체에 대한 허가를 부여
    - GBP(Group-Based Policy) : 복수 주체에 하나의 객체에 대한 허가를 부여
  - 규칙 기반 정책
    - 주체가 갖는 권한에 근거하여 객체의 접근을 제한하는 방법으로 MLP와 CBP가 있음
    - MLP(Multi-Level Policy) : 사용자나 객체별로 지정된 기밀 분류에 따른 정책
    - CBP(Compartment-Based Policy) : 집단별로 지정된 기밀 허가에 따른 정책
  - 역할 기반 정책
    - GBP의 변형된 정책으로 주체의 신분이 아니라 주체가 맡은 역할에 근거하여 객체의 접근을 제한하는 방법

## 접근통제 매커니즘
- 정의된 접근통제 정책을 구현하는 기술적인 방법
- 접근통제 목록, 능력 리스트, 보안 등급, 패스워드, 암호화 등이 있다.
  - 접근통제 목록 : 객체를 기준으로 특정 객체에 대해 어떤 주체가 어떤 행위를 할 수 있는지를 기록한 목록
  - 능력 리스트 : 주체를 기준으로 주체에게 허가된 자원 및 권한을 기록한 목록

## 접근통제 보안모델
- 보안 정책을 구현하기 위한 정형화된 모델
- 접근통제 보안 모델의 종류
  - 기밀성 모델
    - 군사적 목적으로 개발된 최초의 수학적 모델
    - 기밀성 보장이 최우선
    - 군대 시스템 등 특수 환경에서 주로 사용됨
  - 무결성 모델
    - 기밀성 모델에서 발생하는 불법적인 정보 변경을 방지하기 위해 무결성을 기반으로 개발된 모델
  - 접근통제 모델
    - 접근통제 매커니즘을 보안 모델로 발전시킨 것
    - 대표적으로 접근통제 행렬이 있음
    - 접근통제 행렬 : 임의적인 접근통제를 관리하기 위한 보안 모델로, 행은 주체, 열은 객체 즉 행과 열로 주체와 객체의 권한 유형을 나타냄

## 접근통재 조건
- 접근통제 매커니즘의 취약점을 보완하기 위해 접근통제 정책에 부가하여 적용할 수 있는 조건
- 값 종속 통제 : 일반적으로는 객체에 저장된 값에 상관없이 접근통제를 동일하게 허용하지만, 값 종송 통제는 객체에 저장된 값에 따라 다르게 접근통제를 허용해야 하는 경우에 사용
- 다중 사용자 통제 : 지정된 객체에 다수의 사용자가 동시에 접근을 요구하는 경우에 사용
- 컨텍스트 기반 통제
  - 특정 시간, 네트워크 주소, 접근 경로, 인증 수준 등에 근거하여 접근을 제어하는 방법
  - 다른 보안 정책과 결합하여 보안 시스템의 취약점을 보완할 때 사용

## 감사 추적
- 사용자나 애플리케이션이 데이터베이스에 접근하여 수행한 모든 활동을 기록하는 기능
- 오류가 발생한 데이터베이스를 복구하거나 부적절한 데이터 조작을 파악하기 위해 사용


# 049.데이터베이스 백업

## 데이터베이스 백업
- 전산 장비의 장애에 대해 대비하여 데이터베이스에 저장된 데이터를 보호하고 복구하기 위한 작업
- 치명적 데이터 손실을 막기 위해 정기적으로 백업해야 한다

## 로그 파일 
- **데이터베이스의 상태 변화를 시간의 흐름에 따라 기록한 파일**
- DB 복구를 위해 필요한 가장 기본적인 자료
- 로그 파일을 기반으로 데이터베이스를 과거 상태로 복귀시키거나 현재 상태로 재생시켜 DB상태를 일관성 있게 유지할 수 있다.
- 로그 파일은 트랜잭션 시작 시점, 롤백 시점, 데이터 입력/수정/삭제 시점 등에서 기록된다.

## DB복구 알고리즘
- NO-UNDO/REDO
  - DB 버퍼의 내용을 비동기적으로 갱신한 경우의 복구 알고리즘
  - NO-UNDO : 트랜잭션 완료 전에는 변경 내용이 DB에 기록되지 않으므로 취소 불필요
  - REDO : 트랜잭션 완료 후 DB 버퍼에는 기록되어 있고, 저장매체에는 기록되지 않았으므로 트랜잭션 내용을 다시 실행해야 함
- UNDO/NO-REDO
  - DB버퍼의 내용을 동기적으로 갱신한 경우의 복구 알고리즘
  - UNDO : 트랜잭션 완료 전에 시스템이 파손되었다면 변경된 내용을 취소
  - NO-REDO : 트랜잭션 완료 전에 DB 버퍼 내용을 이미 저장 매체에 기록했으므로 트랜잭션 내용을 다시 실행할 필요가 없음
- UNDO/REDO
  - DB버퍼의 내용을 동기/비동기적으로 갱신한 경우의 복구 알고리즘
  - DB기록전에 트랜잭션이 완료될 수 있으므로 완료된 트랜잭션이 DB에 기록되지 못했다면 다시 실행해야 함
- NO-UNDO/NO-REDO
  - DB버퍼의 내용을 동기적으로 저장 매체에 기록하지만 DB와는 다른 영역에 기록한 경우의 복구 알고리즘
  - NO-UNDO : 변경 내용은 DB와 다른 영역에 기록되어 있으므로 취소할 필요가 없음
  - NO-REDO : 다른 영역에 이미 기록되어 있으므로 트랜잭션을 다시 실행할 필요가 없음

## 백업 종류
- 복구 수준에 따라 운영체제를 이용하는 물리 백업과 DBMS 유틸리티를 이용하는 논리 백업으로 나뉨
- 물리 백업
  - DB 파일을 백업하는 방법
  - 백업 속도가 빠르고 작업이 단순하지만 문제 발생 시 원인 파악 및 문제 해결이 어려움
- 논리 백업
  - DB내의 논리적 객체들을 백업하는 방법
  - 복원 시 데이터 손상을 막고 문제 발생시 원인 파악 및 해결이 수월하지만, 백업/복원 시 시간이 많이 소요됨



# 050.스토리지

## 스토리지(Storage)
- 단일 디스크로 처리할 수 없는 **대용량의 데이터를 저장하기 위해 서버와 저장장치를 연결하는 기술**
- 종류로 DAS, NAS, SAN이 있음

## DAS(Direct Attached Storage)
- **서버와 저장장치를 전용 케이블로 직접 연결하는 방식**
- 속도가 빠르고 설치 및 운영이 쉬움
- 초기 구축비용 및 유지보수 비용이 저렴
- 직접 연결 방식이므로 다른 서버에서 접근할 수 없고 파일을 공유할 수 없음
- 확장성 및 유연성이 떨어짐

## NAS(Network Attached Storage)
- **서버와 저장장치를 네트워크를 통해 연결하는 방식**
- 별도의 파일 관리 기능이 있는 NAS Storage가 내장된 저장장치를 직접 관리
- 이더넷 스위치를 통해 다른 서버에서도 스토리지에 접근할 수 있어 파일 공유가 가능
- 장소에 구애받지 않고 저장장치에 쉽게 접근 가능하며 DAS에 비해 확장성과 유연성이 우수

## SAN(Storage Area Network)
- DAS의 빠른 처리와 NAS의 파일 공유 장점을 혼합한 방식으로 **서버와 저장장치를 연결하는 전용 네트워크를 별도로 구성하는 방식**
- 광채널 스위치를 이용해 네트워크 구성하여 처리속도가 빠름
- 저장장치를 공유함으로써 여러 개의 저장장치나 백업 장비를 단일화시킬 수 있다.
- 확장성, 유연성, 가용성이 뛰어나다


# 051.논리 데이터 모델의 변환

## 엔티티(Entity)를 테이블로 변환
- 논리 데이터 모델에서 정의된 엔티티들 물리 데이터 모델의 테이블로 변환하는 것
- 변환 규칙
  - 엔티티 -> 테이블
  - 속성 -> 컬럼
  - 주 식별자 -> 기본키
  - 외부 식별자 -> 외래키
  - 관계 -> 관계

## 슈퍼타입/서브타입을 테이블로 변환
- 슈퍼타입/서브타입은 논리 데이터 모델에서 이용되는 형태이므로 물리 데이터 모델을 설계할 때는 슈퍼타입/서브타입을 테이블로 변환해야 한다.
- 슈퍼타입/서브타입 모델을 테이블로 변환하는 방법에는 슈퍼타입 기준 테이블 변환, 서브타입 기준 테이블 변환, 개별타입 기준 테이블 변환이 있다.

## 슈퍼타입 기준 테이블 변환
- **서브타입을 슈퍼타입에 통합하여 하나의 테이블로 만드는 것**
- 서브타입에 속성이나 관계가 적을 경우에 적용하는 방법
- 하나로 통합된 테이블에는 서브타입의 모든 속성이 포함되어야 한다.

## 서브타입 기준 테이블 변환
- **슈퍼타입 속성들을 각각의 서브타입에 추가하여 서브타입들을 개별적인 테이블로 만드는 것**
- 서브타입에 속성이나 관계가 많이 포함된 경우 적용

## 개별타입 기준 테이블 변환
- **슈퍼타입과 서브타입들을 각각의 개별적인 테이블로 변환하는 것**
- 슈퍼타입과 서브타입 테이블들 사이에는 각각 1대1 관계가 형성됨

## 속성을 칼럼으로 변환
- 논리 데이터 모델에서 정의한 속성을 물리 데이터 모델의 컬럼으로 변환
- 일반 속성 변환 : 속성과 컬럼은 명칭이 반드시 일치할 필요는 없으나 개발자와 사용자 간 의사소통을 위하여 가능한 한 표준화된 약어를 사용하여 일치시키는 것이 좋음
- Primary UID를 기본키로 변환 : 논리 데이터 보델에서의 Primary UID는 물리 데이터 모델의 기본키로 만듬
- Primary UID(관계의 UID Bar)를 기본키로 변환 : 다른 엔티티와의 관계로 인해 생성된 Primary UID는 물리 데이터 모델의 기본키로 만듬
  - UID Bar란 엔티티에 포함된 고유 속성의 식별자(UID)가 아니라 다른 엔티티와의 관계로 인해 생성된 식별자(UID)를 의미
- Secondary(Alternate) UID를 유니크키로 변환 : 논리 모델링에서 정의된 Secondary UID 및 Alternate Key는 물리 모델에서 유니크키로 만듬
  - 유니크키는 해당 속성에 입력된 값이 유일하다는 것을 보장하기 위한 제약 조건인 유니크 속성이 설정된 키이다

## 관계를 외래키로 변환
논리 데이터 모델에서 정의된 관계는 기본키와 이를 참조하는 외래키로 변환한다.


# 052.자료 구조

## 자료 구조
- 자료를 기억장치의 공간 내에 저장하는 방법과 자료 간의 관계, 처리 방법 등을 연구 분석하는 것
- 저장 공간의 효율성과 실행시간의 단축을 위해 사용
- 자료 구조의 분류
  - 선형 구조
    - 배열
    - 선형 리스트
      - 연속 리스트
      - 연결 리스트
    - 스택
    - 큐
    - 데크
  - 비선형 구조
    - 트리
    - 그래프

## 배열(Array)
- **크기와 형이 동일한 자료들이 순서대로 나열된 자료의 집합**
- 반복적인 데이터 처리 작업에 적합한 구조
- 정적인 자료 구조로, 기억장소의 추가가 어렵다
- 데이터 삭제 시 기억장소가 빈 공간으로 남아있어 메모리의 낭비가 발생한다

## 연속 리스트(Contiguous List)
- **배열과 같이 연속되는 기억장소에 저장되는 자료구조**
- 중간에 데이터를 삽입하기 위해서는 연속된 빈 공간이 있어야 한다.
- 삽입/삭제 시 자료의 이동이 필요하다.

## 연결 리스트(Linked List)
- **자료들을 임의의 공간에 기억시키되 노드의 포인터 부분을 이용하여 서로 연결시킨 자료 구조**
- 연결을 위한 링크 부분이 필요하기 때문에 기억 공간의 이용 효율이 좋지 않다.
- 접근 속도가 느리고 연결이 끊어지면 다음 노드를 찾기 어렵다.

## 스택(Stack)
- **리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료구조**
- 후입선출(LIFO) 방식으로 자료를 처리한다.
- 저장할 기억 공간이 없는 상태에서 데이터가 삽입되면 오버플로가 발생
- 삭제할 데이터가 없는 상태에서 데이터를 삭제하면 언더플로 발생

## 큐(Queue)
- **리스트의 한쪽에서는 삽입 작업, 다른 한쪽에서는 삭제 작업이 이루어지는 자료 구조**
- 선입선출(FIFO)방식으로 자료 처리
- 시작을 표시하는 프런트 포인터와 끝을 표시하는 리어 포인터가 있다.

## 그래프(Graph)
- **정점(Vertex)와 간선(Edge)의 두 집합으로 이루어지는 자료 구조**
- 사이클이 없는 그래프를 트리라 한다.
- 간선의 방향성 유무에 따라 방향 그래프와 무방향 그래프로 구분된다

## 방향/무방향 그래프의 최대 간선 수
- 방향 그래프의 최대 간선 수 : n(n - 1)
- 무방향 그래프에서 최대 간선 수 : n(n - 1) / 2


# 053.트리

## 트리(Tree)
- 정점(노드)과 선분(브랜치)을 이용해 사이클을 이루지 않도록 구성한 그래프의 특수한 형태
- 하나의 기억 공간을 노드라 하며 노드와 노드를 연결하는 선을 링크라고 한다.

## 트리 관련 용어
- 노드(Node) : 트리의 기본 요소로서 자료 항목과 다른 항목에 대한 가지(브랜치)를 합친 것
- 근 노드(Root Node) : 트리의 맨 위에 있는 노드
- 디그리(Degree) : 각 노드에서 뻗어나온 가지의 수
- 단말 노드(Terminal Node) : 자식이 하나도 없는 노드, 즉 Degree가 0인 노드
- 비단말 노드(Non-Terminal Node) : 자식이 하나라도 있는 노드, 즉 Degree가 0이 아닌 노드
- 조상 노드(Ancester Node) : 임의의 노드에서 근 노드에 이르는 경로상에 있는 노드들
- 자식 노드(Son Node) : 어떤 노드에 연결된 다음 레벨의 노드들
- 부모 노드(Parent Node) : 어떤 노드에 연결된 이전 레벨의 노드들
- 형제 노드(Sibling) : 동일한 부모를 갖는 노드들
- 레벨(Level) : 근 노드의 레벨을 1로 가정한 후 어떤 Level이 L이면 자식 노드는 L + 1
- 깊이(Depth) : 트리에서 노드가 가질 수 있는 최대의 레벨
- 숲(Forest) : 여러 개의 트리가 모여 있는 것
- 트리의 디그리 : 노드들의 디그리 중에서 가장 많은 수


# 054.이진 트리

## 이진 트리
- **차수가 2 이하인 도드들로 구성된 트리**
- 이진 트리의 레벨 i에서 최대 노드의 수는 2^(i - 1)
- 이진 트리에서 단말 노드의 수가 n, 차수가 2인 노드 수가 m이라 할 때 n = m + 1이 된다

## 트리의 운행법
- 트리를 구성하는 각 노드들을 찾아가는 방법을 운행법이라 한다.
- 이진 트리를 운행하는 방법은 산술식의 표기법과 연관성을 갖는다.
- 이진 트리의 운행법은 다음 세 가지가 있다.
  - Preorder(전위) 운행 : Root -> Left -> Right 순으로 운행한다.
  - Inorder(중위) 운행 : Left -> Root -> Right 순으로 운행한다.
  - Postorder(후위) 운행 : Left -> Right -> Root 순으로 운행한다.

## 수식의 표기법
- 이진 트리로 만들어진 수식을 전/중/후위로 운행하면 각각 전/중/후위 표기법이 된다
  - 전위 표기법(PreFix) : 연산자 -> Left -> Right ( + A B )
  - 중위 표기법(InFix) : Left -> 연산자 -> Right ( A + B )
  - 후위 표기법(PostFix) : Left -> Right -> 연산자 ( A B + )


# 055.정렬

## 삽입 정렬(Insertion Sort)
- 가장 간단한 정렬 방식으로 **이미 순서화된 페일에 새로운 하나의 레코드를 순서에 맞게 삽입시켜 정렬하는 방식**
- 평균과 최악 모두 수행 시간 복잡도는 O(n^2)

## 선택 정렬(Selection Sort)
- **n개의 레코드 중 최소값을 찾아 첫 번째 레코드 위치에 놓고 나머지(n - 1)개 중에서 다시 최소값을 찾아 두 번째 레코드 위치에 놓는 방식을 반복하여 정렬하는 방식**
- 평균과 최악 모두 수행 시간 복잡도는 O(n^2)

## 버블 정렬(Bubble Sort)
- **인접한 두 개의 레코드 키 값을 비교하여 그 크기에 따라 레코드 위치를 서로 교환하는 정렬 방식**
- 평균과 최악 모두 수행 시간 복잡도는 O(n^2)

## 쉘 정렬(Shell Sort)
- **입력 파일을 어떤 매개변수의 값으로 서브파일을 구성하고, 각 서브파일을 삽입 정렬 방식으로 순서 배열하는 과정을 반복하는 정렬 방식**
- 삽입 정렬을 확장한 개념
- 평균 수행 시간 복잡도는 O(n^1.5), 최악 수행 시간 복잡도는 O(n^2)

## 퀵 정렬(Quick Sort)
- **키를 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽 서브 파일에 분해시키는 과정을 반복하는 정렬 방식**
- 레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어가면서 정렬
- 평균 수행 시간 복잡도는 O(n * log(n)), 최악 수행 시간 복잡도는 O(n^2)

## 힙 정렬(Heap Sort)
- **전이진 트리를 이용한 정렬 방식**
- 구성된 전이진 트리를 힙 트리로 변환하여 정렬
- 평균과 최악 모두 시간 복잡도는 O(n * log(n))

## 2-Way 합병 정렬(Merge Sort)
- **이미 정렬되어 있는 두 개의 파일을 한 개의 파일로 합병하는 정렬 방식**
- 평균과 최악 모두 시간 복잡도는 O(n * log(n))

## 기수 정렬(Radix Sort, Bucket Sort)
- **큐를 이용하여 자릿수별로 정렬하는 방식**
- 레코드의 키 값을 분석하여 같은 수 또는 같은 문자끼리 그 순서에 맞는 버킷에 분배하였다가 버킷의 순서대로 레코드를 꺼내 정렬
- 평균과 최악 모두 시간 복잡도는 O(dn)


1. 1-d / 2-c / 3-a / 4-b / 5-e
2. 관계 / 속성 / 개체
3. 기본키 / 후보키 / 외래키
답 : 후보키 / 대체키 / 외래키
4. 5 / 4
5. 다른 튜플들에서 중복값이 나올 수 있다.
답 : 기본키는 중복값을 가질 수 없는데 학과나 학년에 중복값이 존재해서
6. 함수 종속성 / 학번 -> 학과
답 : 함수적 종속
7. 몰루
답 : 예금계좌 릴레이션의 지점명 중 화양점과 명동점이 지점 릴레이션의 지점명 속성에 존재하지 않기 때문에
8. ㄱ ㄴ ㄷ ㄹ
9. 1-ㄴ / 2-ㄷ / 3-ㄱ / 4-ㄹ / 5-ㅁ
10. 제 3정규형
11. 메타 데이터
답 : 개념 스키마
12. 제 1정규화, 수강과목 도메인을 원자값으로 만들어주었다.
13. 삽입 이상 / 기본키에 해당하는 학번에 널값이 들어갔다.
14. 상품명 / 주문수량 / 생산자
답 : 생산자 상품명 상품가격
15. 제 2정규화
답 : 제 3정규화
16. 현실 세계의 데이터를 추상화하여 물리적 저장장치에 저장한 것
답 : 공동으로 사용할 데이터를 중복을 배제하여 통합하고 저장장치에 저장하여 항상 사용할 수 있도록 운영하는 데이터
17. 제 2정규화 / 생산번호에 완전 함수적 종속적인 속성들을 따로 나눠 새 릴레이션을 만들었다. / 제 3정규화 / 상품명에 이행적 함수적 종속적인 상품가격 속성을 따로 나눠 새 릴레이션을 만들었다.
18. 몰루
답 : 데이터의 논리적 구조를 변경시키더라도 응용 프로그램은 영향을 받지 않는 성질
19. 튜플 / 도메인 / 기본키 / 외래키
답 : 테이블 / 컬럼 / 기본키 / 외래키
20. 슈퍼타입 기준 / 서브타입 기준 / 1대1 매칭
답 : 슈퍼타입 기준 / 서브타입 기준 / 개별타입 기준
21. 개념적 설계 단계
22. 설계 속성 / 추가 속성
답 : 설계 속성 / 파생 속성
23. 분할 관계 / 재귀 관계
답 : 배타 관계 / 재귀 관계
24. 직사각형 / 마름모 / 타원
25. 속성 / 도메인 / 스키마 / 스키마
답 : 속성 / 튜플 / 스키마 / 인스턴스
26. 48
27. 외래키
28. 릴레이션의 속성 중 최소성과 유일성을 만족하는 속성들
답 : 속성들 중 튜플을 유일하게 식별하기 위해 사용되는 속성들의 부분집합
29. 정합성
답 : 무결성
30. 몰루
답 : 외래키 값은 널이거나 참조 릴레이션의 기본키 값과 동일해야 한다는 규정
31. 7 / 12
32. Division / Select
33. 집합의 연산을 수학적 기호화 수식으로 표현한 것
답 : 원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절차적 언어
34. DB에 잘못된 입력, 갱신, 삭제 등으로 인해 DB의 정합성이 깨져버린 것
답 : DB내 데이터들이 불필요하게 중복되어 릴레이션 조작 시 예기치 않게 발생하는 곤란한 현상
35. 정규화
36. 보이스코드 정규화
37. 반정규화
38. 원자성
39. Create / Read / Update / Delete
40. 뷰
41. 디렉토리
답 : 인덱스
42. 파티션
43. 유일성
답 : 병행 투명성
44. 역할 기반 접근통제
45. 몰루
답 : 접근통제 정책/매커니즘/보안모델
46. NAS / DAS / SAN
47. 배열
48. 연결 리스트
49. 큐
답 : 스택
50. 56
51. 3 / 7
52. DBGHEFCA
53. AB*CDE/-+
답 : -+*ABC/DE
54. 선택 정렬
답 : 삽입 정렬
55. 6 3 5 7 9
56. 버킷 정렬