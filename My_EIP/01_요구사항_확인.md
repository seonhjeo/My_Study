# 001. 소프트웨어 생명 주기

## 소프트웨어 생명 주기(Software Life Cycle)
- 소프트웨어 생명 주기는 **소프트웨어를 개발하기 위한** 설계, 운용, 유지보수 등의 **과정을 각 단계별로 나눈 것**
- 소프트웨어 생명 주기는 소프트웨어 개발 단계와 각 단계별 주요 활동 그리고 활동의 결과에 대한 산출물로 표현한다.
- 대표적인 생명 주기 모형
  - 폭포수 모형, 프로토타입 모형, 나선형 모형, 애자일 모형

## 폭포수 모형(Waterfall Model)
- 폭포수 모형은 이전 단계로 돌아갈 수 없다는 전제하에 **각 단계를 확실히 매듭짓고** 그 **결과를** 철저하게 **검토하여 승인 과정을 거친 후에 다음 단계를 진행하는 개발 방법론**
- 가장 오래되고 가장 폭넓게 사용된 전통적인 소프트웨어 생명 주기 모형이다.
- 고전적 생명 주기 모형이라고도 한다.
- 모형을 적용한 경험과 성공 사례가 많다.
- 각 단계가 끝난 후에는 다음 단계를 수행하기 위한 결과물이 명확하게 산출되어야 한다.

## 프로토타입 모형(Prototype Model, 원형 모형)
- 프로토타입 모형은 사용자의 요구사항을 파악하기 위해 **실제 개발될 소프트웨어의 견본품을 만들어 최종 결과물을 예측하는 모형**
- 견본품은 사용자와 시스템 사이의 인터페이스에 중점을 두어 개발한다.

## 나선형 모델(Spiral Model, 점진적 모형)
- 나선형 모형은 나선을 따라 돌듯이 **여러 번의 소프트웨어 개발 과정을 거쳐 점진적으로** 완벽한 최종 소프트웨어를 **개발하는 모형**
- 보헴(Bohem)이 제안
- 폭포수 모형과 프로토타입 모형의 장점에 위험 분석 기능을 추가한 모형
- 누락되거나 추가된 요구사항을 첨가할 수 있음
- 유지보수 과정이 필요없음
- **4가지 주요 활동** : 계획 수립 -> 위험 분석 -> 개발 및 검증 -> 고객 평가

## 애자일 모형(Agile Model)
- 애자일은 민첩한, 기민한이라는 의미로 고객의 **요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발하는 모형**
- 어느 특정 개발 방법론이 아니라 좋은 것을 바르고 낭비 없게 만들기 위해 고객과의 소통에 초점을 맞춘 방법론을 통칭
- 폭포수 모형과 대조적이며 기업 활동 전반에 걸쳐 사용
- **대표적인 개발 모형** : 스크럼(Scrum), XP(eXtreme Programming), 칸반(Kanban), Lean, 기능 중심 개발(FDD) 등

## 애자일 개발 4가지 핵심 원칙
- 프로세스와 도구보다는 개인과 상호작용에 더 가치를 둔다
- 방대한 문서보다는 실행되는 SW에 더 가치를 둔다
- 계약 협상보다는 고객과 협업에 더 가치를 둔다
- 계획을 따르기보다는 변화에 반응하는 것에 더 가치를 둔다.

## 소프트웨어 공학(SE; Software Engineering)
- 소프트웨어 공학은 **소프트웨어의 위기를 극복하기 위한 방안으로 연구된 학문**
- 여러가지 방법론과 도구, 관리 기법들을 통해 소프트웨어의 품질과 생산성 향상을 목적으로 함
- 소프트웨어 공학의 기본 원칙
  - 현대적인 프로그래밍 기술을 계속적으로 적용해야 한다.
  - 개발된 소프트웨어의 품질이 유지되도록 지속적으로 검증해야 한다.
  - 소프트웨어 개발 관련 사항 및 결과에 대한 명확한 기록을 유지해야 한다.


# 002.스크럼(Scrum) 기법

## 스크럼(Scrum)
- **팀이 중심이 되어 개발의 효율성을 높이는 기법**
- 팀원 스스로가 스크럼 팀을 구성하고 개발 작업에 관한 모든 것을 스솔 해결할 수 있어야 함

## 스크럼 팀
- 제품 책임자(PO; Product Owner)
  - 요구사항이 담긴 백로그를 작성하는 주체
  - 이해관계자들 중 개발될 제품에 대한 이해도가 높고 요구사항을 책임지고 의사를 결정할 사람으로 선정
- 스크럼 마스터(SM; Scrum Master)
  - 스크럼 팀이 스크럼을 잘 수행할 수 있도록 가이드 역할을 수행
- 개발팀(DT; Development Team)
  - 제품 책임자와 스크럼 마스터를 제외한 모든 팀원으로 제품 개발 수행

## 스크럼 개발 프로세스
- 스프린트 계획 회의
  - 제품 백로그 중 이번 스프린트에서 수행할 작업을 대상으로 단기 일정을 수립하는 회의
- 스프린트
  - 실제 개발 작업을 진행하는 과정으로, 보통 2 ~ 4주 정도의 기간 내에서 진행
- 일일 스크럼 회의
  - 모든 팀윈이 매일 약속된 시간에 약 15분간 진행 상황을 점건하는 회의
  - 남은 작업 시간은 소멸 차트(Burn-down Chart)에 표시
- 스프린트 검토 회의
  - 부분 또는 전체 완성 제품이 요구사항에 잘 부합하는지 테스팅하는 회의
- 스프린트 회고
  - 정해놓은 규칙 준수 여부 및 개선할 점을 확인하고 기록하는 것


# 003.XP(eXtreme Programming) 기법

## XP
- 수시로 발생하는 고객의 **요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 향상시키는 방법**
- 짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적인 참여를 통한 소프트웨어를 빠르게 개발하는 것을 목적으로 함
- 릴리즈의 기간을 짧게 반복하면서 고객의 요구사항 반영에 대한 가시성을 높임
- XP의 5가지 핵심 가치
  - 의사소통 : 개발자, 관리자, 고객 간의 원활한 의사소통
  - 단순성 : 부가적 기능, 사용되지 않는 구조와 알고리즘 배제
  - 용기 : 고객의 요구사항 변화에 능동적인 대처
  - 존중 : 모든 프로젝트 관리자는 팀원의 기여를 존중
  - 피드백 : 지속적인 테스트와 반복적 결함 수정, 빠른 피드백

## XP 개발 프로세스
- 릴리즈 계획 수립
  - 부분 혹은 전체 개발 완료 시점에 대한 일정 수립
  - 몇 개의 스토리가 적용되어 부분적으로 기능이 완료된 제품을 제공하는 것을 릴리즈라고 함
- 이터레이션
  - 실제 개발 작업을 진행하는 과정으로, 보통 1~3주 정도의 기간으로 진행됨
- 승인 검사
  - 하나의 이터레이션 안에서 부분 완료 제품이 구현되면 수행하는 테스트
- 소규모 릴리즈
  - 요구사항에 유연하게 대응할 수 있도록 릴리즈의 규모를 축소한 것

## XP의 주요 실천 방법
- Pair Programming(짝 프로그래밍)
  - 다른 사람과 함께 프로그래밍을 수행함으로써 개발에 대한 책임을 공동으로 나눠 갖는 환경 조성
- Collective OwnerShip(공동 코드 소유)
  - 개발 코드에 대한 권한과 책임을 공동으로 소유
- Test-Driven Development(테스트 주도 개발)
  - 개발자가 실제 코드를 작성하기 전에 테스트 케이스를 먼저 작성하므로 자신이 무엇을 해야할지를 정확히 파악함
  - 테스트가 지속적으로 진행될 수 있도록 자동화된 테스팅 도구(구조, 프레임워크)를 사용함
- Whole Team(전체 팀)
  - 개발에 참여하는 모든 구성원(고객 포함)들은 각자 자신의 역할이 있고, 그 역할에 대한 책임을 가져야 함
- Continuous Integration(계속적인 통합)
  - 모듈 단위로 나눠서 개발된 코드들은 하나의 작업이 마무리될 때마다 지속적으로 통합됨
- Refactoring(리팩토링)
  - 프로그램 기능의 변경 없이 시스템을 재구성
  - 프로그램을 쉽게 이해하고 쉽게 수정하여 빠르게 개발할 수 있도록 하기 위함
- Small Release(소규모 릴리즈)
  - 릴리즈 기간을 짧게 함으로써 고객의 요구 변화에 신속하게 대응


# 004.개발 기술 환경 파악

## 개발 기술 환경 파악의 개요
- 개발하고자 하는 소프트웨어와 관련된 운영체제, 데이터베이스 관리 시스템, 미들웨어 등을 선정할 때 고려해야 할 사항을 기술하고, 오픈 소스를 사용할 때 주의해야 할 내용 제시

## 운연체제(OS, Operating System)
- **컴퓨터 시스템의 자원을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효율적으로 사용할 수 있도록 환경을 제공하는 소프트웨어**
- 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스로서 동작하는 시스템 소프트웨어의 일종
- 다른 응용 프로그램이 유용한 작업을 할 수 있도록 환경 제공
- 운영체제 관련 요구사항 식별 시 고려사항 : 가용성, 성능, 기술 지원, 주변 기기, 구축 비용

## 데이터베이스 관리 시스템(DBMS)
- **사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정볼르 생성해 주고, 데이터베이스를 관리해 주는 소프트웨어**
- 기존의 파일 시스템이 갖는 데이터의 종속성과 중복성 문제를 해결하기 위해 제안된 시스템
- 모든 응용 프로그램들이 데이터베이스를 공용할 수 있도록 관리
- DBMS 관련 요구사항 식별 시 고려사항 : 가용성, 성능, 기술 지원, 상호 호환성, 구축 비용

## 웹 애플리케이션 서버(WAS, Web Application Server)
- 웹 애플리케이션 서버는 사용자의 요구에 따라 변하는 **동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어**
- 데이터 접근, 세션 관리, 트랜잭션 관리 등을 위한 라이브러리 제공
- 주로 데이터베이스 서버와 연동해 사용
- WAS 관련 요구사항 식별 시 고려사항 : 가용성, 성능, 기술 지원, 구축 비용

## 오픈 소스(Open Source)
- **누구나 별다른 제한 없이 사용할 수 있도록 소스 코드를 공개한 소프트웨어**
- 오픈 소스 라이선스를 만족한다
- 오픈 소스 관련 요구사항 식별 시 고려사항 : 라이선스 종류, 상요자 수, 기술 지속 가능성


# 005.요구사항 정의

## 요구사항
- **소프트웨어가 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명과 정상적으로 운용되는 데 필요한 제약조건**
- 소프트웨어 개발이나 유지 보수 과정에서 필요한 기준과 근거 제공
- 개발에 참여하는 이해관계자들간의 의사소통을 원활하게 하는 데 도움이 됨
- 요구사항의 유형
  - 기능 요구사항
  - 비기능 요구사항
  - 사용자 요구사항
  - 시스템 요구사항

## 기능 요구사항(Functional Requirements)
- 시스템이 무엇을 하는지, 어떤 기능을 하는지 등의 **기능이나 수행과 관련된 요구사항**이다
- 시스템의 입력이나 출력으로 무엇이 포함되어야 하는지에 대한 사항
- 시스템이 어떤 데이터를 저장하거나 연산을 수행해야 하는지에 대한 사항
- 시스템이 반드시 수행해야만 하는 기능
- 사용자가 시스템을 통해 제공받기를 원하는 기능

## 비기능 요구사항(Non-Functional Requirements)
- **품질이나 제약사항에 관련된 요구사항**
- 시스템 장비 구성, 성능, 인터페이스, 데이터 구축에 필요한 요구사항 등
- 테스트 보안, 품질 요구사항 등
  - 품질 요구사항 : 가용성, 정합성, 상호 호환성, 대응성, 이식성, 확장성, 보안성 등
- 제약사항, 프로젝트 관리/자원 요구사항 등

## 사용자 요구사항(User Requirements)
- **사용자 관점에서 본 시스템이 제공해야 하는 요구사항**
- 사용자를 위한 것으로, 친숙한 표현으로 이해하기 쉽게 작성

## 시스템 요구사항(System Requirements)
- **개발자 관점에서 본 시스템 전체가 사용자와 다른 시스템에 제공해야 할 요구사항**
- 사용자 요구사항에 비해 전문적이고 기술적인 용어로 표현
- 소프트웨어 요구사항이라고도 한다.


# 006.요구사항 개발 프로세스

## 요구사항 개발 프로세스
- 개발 대상에 대한 **요구사항을 도출하고 분석한 후 명세서에 정리한 다음 확인 및 검증하는 활동**
- 진행되기 전 타당성 조사가 선행되어야 한다.
  - 타당성 조사 : 개발 프로세스가 비즈니스 목적에 부합되는지, 예산은 적정한지 등에 대한 정보를 수집 평가한 보고서를 토대로 수행
- 요구사항 개발은 요구공학의 한 요소
- 요구사항 개발의 실행순서 : 도출(수집) -> 분석 -> 명세 -> 확인(검증)

## 요구사항 도출(Requirement Elicitation, 요구사항 수집)
- **시스템 개발에 관련된 사람들이 서로 의견을 교환하여 요구사항을 어떻게 수집할 것인지를 식별하고 이해하는 과정**
- 개발자와 고객 사이의 관계가 만들어지고, 이해관계자가 식별된다.
- 소프트웨어 개발 생명 주기(SDLC)동안 지속적으로 반복된다.
- 요구사항을 도출하는 주요 기법
  - 청취와 인터뷰, 설문, 브레인스오밍, 워크샵, 프로토타이핑, 유스케이스

## 요구사항 분석(Requirement Analysis)
- **요구사항 중 명확하지 않거나 모호하여 이해되지 않는 부분을 파악하고 걸러내기 위한 과정**
- 요구사항의 타당성을 조사하고 비용과 일정에 대한 제약 설정
- 서로 상충되는 요구사항이 있으면 이를 중재
- 분석에 사용되는 대표적인 도구
  - 자료 흐름도(DFD), 자료 사전(DD)

## 요구사항 명세(Requirement Specification)
- **분석된 요구사항을 바탕으로 모델을 작성하고 문서화하는 것**
- 기능 요구사항은 빠짐없이, 비기능 요구사항은 필수적인 것만 기술
- 구체적인 명세를 위해 소단위 명세서가 사용될 수 있음

## 요구사항 확인(Requirement Validation, 요구사항 검증)
- **개발 자원을 요구사항에 할당하기 전에 요구사항 명세서가 정확하고 완전하게 작성되었는지를 검토하는 활동**
- 이해관계자들이 검토
- 요구사항 관리 도구를 이용해 요구사항 정의 문서들에 대해 형상관리를 수행한다.

## 요구공학(Requirement Engineering)
- **요구사항을 정의하고 분석, 및 관리하는 프로세스를 연구하는 학문**
- 요구사항 변경의 원인과 처리 방법을 이해하고, 요구사항 관리 프로세스의 품질을 개선해 소프트웨어 프로젝트의 실패를 최소화하는 것을 목표로 함

## 요구사항 명세 기법

### 정형 명세 기법
- 기법 : 수학적 원리 기반, 모델 기반
- 작성방법 : 수학적 기호, 정형화된 표기법
- 특징
  - 요구사항을 정확하고 간결하게 표현할 수 있음
  - 요구사항에 대한 결과가 작성자에 관계없이 일관성이 있으므로 완전성 검증이 가능
  - 표기법이 어려워 사용자가 이해하기 어려움

### 비정형 명세 기법
- 기법 : 상태/기능/객체 중심
- 일반 명사, 동사 등의 자연어를 기반으로 서술 또는 다이어그램 작성
- 특징
  - 자연어 사용으로 인해 요구사항에 대한 결과가 작성자에 따라 다를 수 있어 일관성이 떨어지고 해석이 달라질 수 있음
  - 내욜의 이해가 쉬워 의사소통이 용이함


# 007.요구사항 분석

## 요구사항 분석(Requirement Analysis)
- 소프트웨어 개발의 실제적인 첫 단계로, **개발 대상에 대한 사용자의 요구사항을 이해하고 문서화하는 활동**
- 사용자 요구의 타당성을 조사하고 비용과 일정에 대한 제약을 설정
- 사용자의 요구를 정확하게 추출해 목표를 설정

## 구조적 분석 기법
- **자료의 흐름과 처리를 중심으로 하는 요구사항 분석 방법**
- 도형 중심의 분석용 도구와 분석 절차를 이용하여 사용자의 요구사항을 파악하고 문서화
- 하향식 방법을 사용해 시스템 세분화 가능
- 주요 구조적 분석 기법 도구 : 자료 흐름도(DFD), 자료 사전(DD), 소단위 명세서, 개체 관계도(ERD), 상태 전이도(STD), 제어 명세서

## 자료 흐름도(DFD; Data Flow Diagram)
- **자료의 흐름 및 변환 과정과 기능을 도형 중심으로 기술하는 방법**
- 자료 흐름 그래프, 버블 차트라고도 함
- 자료 흐름 처리를 중심으로 하는 구조적 분석 기법에 이용됨

## 자료 흐름도 기본 구성
- 프로세스 : 자료를 변환시키는 시스템의 한 부분(처리 과정)을 나타내며 처리, 기능, 변환, 버블이라고도 함
- 자료 흐름 : 자료의 이동(흐름)이나 연관관계를 나타냄
- 자료 저장소 : 시스템에서의 자료 저장소(파일, 데이터베이스 등)을 나타냄
- 단말 : 시스템과 교신하는 외부 개체로 입력 및 출력을 처리

## 자료 사전(DD; Data Dictionary)
- **자료 흐름도에 있는 자료를 더 자세하게 정의하고 기록한 것**
- 데이터를 설명하는 데이터로, 메타 데이터라고도 한다.
- 자료 사전의 표기 기호
  - `=` : 자료의 정의
  - `+` : 자료의 연결
  - `( )` : 자료의 생략
  - `[ ]` : 자료의 선택
  - `{ }` : 자료의 반복
  - `" "` : 자료의 설명


# 008.요구사항 분석 CASE와 HIPO

## 요구사항 분석용 CASE(자동화 도구)
- **요구사항을 자동으로 분석하고, 요구사항 분석 명세서를 기술하도록 개발된 도구**
- 대표적인 요구사항 분석용 CASE
  - SADT
    - 시스템 정의, 소프트웨어 요구사항 분석, 시스템/소프트웨어 설계를 위한 도구
    - SoftTech사에서 개발
    - 구조적 요구 분석을 하기 위해 블록 다이어그램을 채택한 자동화 도구
  - SREM
    - TRW사가 실시간 처리 소프트웨어 시스템에서 요구사항을 명확히 기술하도록 할 목적으로 개발한 도구
    - RSL과 REVS를 사용하는 자동화 도구
  - PSL/PSA
    - PSL과 PSA를 사용하는 자동화 도구로 미시간대에서 개발
  - TAGS
    - 시스템 공학 방법 응용에 대한 자동 접근 방법
    - 개발 주기의 전 과정에 이용할 수 있는 통합 자동화 도구

## HIOP(Hierarchy Input Process Output)
- 시스템의 분석 및 설계 또는 문서화에 사용되는 기법으로, **시스템 실행 과정인 입력, 처리, 출력 기능을 표현한 것**
- 하향식 소프트웨어 개발을 위한 문서화 도구
- 기능과 자료의 의존 관계를 동시에 표현할 수 있음
- 기호, 도표를 사용하므로 보기 쉽고 이해하기 쉬움
- 시스템의 기능을 여러 개의 고유 모듈로 분할하여 이들 간의 인터페이스를 계층 구조로 표현한 것을 HIPO Chart라고 함
- HIPO Chart의 종류 : 가시적 도표, 총체적 도표, 세부적 도표


# 009.UML의 개요

## UML(Unified Modeling Language)
- **시스템 개발 과정에서 시스템 개발자와 고객 또는 개발자 상호 간의 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어**
- Rumbaugh, Booch, Jacobson 등의 객체지향 방법론의 장점을 통합함
- OMG에서 표준으로 지정함
- UML의 구성 요소 : 사물, 관계, 다이어그램

## 사물(Things)
- **다이어그램 안에서 관계가 형성될 수 있는 대상들**을 뜻함
- 모델을 구성하는 가장 중요한 기본 요소
- 사물의 종류
  - 구조 사물(Structural Things)
    - 시스템의 개념적, 물리적 요소 표현
    - 클래스, 유스케이스, 컴포넌트, 인터페이스, 노드 등
  - 행동 사물(Behavioral Things)
    - 시간과 공간에 따른 요소들의 행위 표현
    - 상호작용(Interaction), 상태 머신(State Machine) 등
  - 그룹 사물(Grouping things)
    - 요소들을 그룹으로 묶어서 표현
    - 패키지(Package)
  - 주해 사물(Annotation things)
    - 부가적인 설명이나 제약조건 등을 표현
    - 노트(Note)


# 010.UML 관계

## 관계(RelationShip)
- **사물과 사물 사이의 연관성을 표현하는 것**
- 관계의 종류 : 연관, 집합, 포함, 일반화, 의존, 실체화

## 연관(Association) 관계
- **2개 이상의 사물이 서로 관련되어 있는 관계**
- 사물 사이를 실선으로 연결하고 화살표로 방향을 표현
- 양방향 관계인 경우 화살표는 생략하고 실선으로만 표현
- 다중도를 선 위에 표기
- ex) 사람이 소유한 집, 선생님과 학생의 관계 등

## 집합(Aggregation) 관계
- **하나의 사물이 다른 사물에 포함되어 있는 관계**
- 포함하는 쪽과 포함되는 쪽은 서로 독립적
- 포함되는 쪽에서 포함하는 쪽으로 속이 빈 마름모를 연결해 표현
- ex) 컴퓨터에 연결할 수 있는 프린터

## 포함(Composition) 관계
- 집합 관계의 특수한 형태로 **포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 관계**
- 포함하는 쪽과 포함되는 쪽은 서로 독립될 수 없고 생명주기를 함께함
- 포함되는 쪽에서 포함하는 쪽으로 속이 찬 마름모를 연결하여 표현
- ex) 문이 없어지면 쓸모가 없어지는 열쇠

## 일반화(Generalization) 관계
- **하나의 사물이 다른 사물에 비해 더 일반적이거나 구체적인 관계**
- 보다 일반적인 개념을 상위, 보다 구체적인 개념을 하위라고 일컬음
- 구체적 개념에서 일반적 개념으로 빈 화살표를 연결해 표현
- ex) 아메리카노와 에스프레소는 차의 일종

## 의존(Dependency) 관계
- 연관 관계와 같이 사물 사이에 서로 연관은 있으나, 필요에 의해 **서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계**
- 서로 소유의 관계는 아니지만 하나의 변화가 다른 사물에도 영향을 미치는 관계
- 영향을 주는 사물이 영향을 받는 사물 쪽으로 점선 화살표를 연결해 표현
- ex) 등급이 높으면 할인율을 적용하고, 등급이 낮으면 할인율을 적용하지 않음

## 실체화(Realization) 관계
- **사물이 할 수 있거나 해야 하는 기능으로 서로를 그룹화 할 수 있는 관계**
- 사물에서 기능 쪽으로 속이 빈 점선 화살표를 연결하여 표현
- ex) 비행기와 새는 둘 다 날 수 있다.


# 011.UML 다이어그램

## 다이어그램(Diagram)
- **사물과 관계를 도형으로 표현한 것**
- 여러 관점에서 시스템을 가시화한 뷰를 제공함으로써 의사소통에 도움을 줌
- 정적 모델링에서는 주로 구조적 다이어그램을, 동적 모델링에서는 주로 행위 다이어그램 사용

## 구조적(Structural) 다이어그램의 종류
- 클래스 다이어그램(Class Diagram)
  - 클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현함
- 객체 다이어그램(Object Diagram)
  - 클래스에 속한 사물(객체)들, 즉 인스턴스(Instance)를 특정 시점의 객체와 객체 사이의 관계로 표현
  - 럼바우 객체지향 분석 기법에서 객체 모델링에 활용됨
- 컴포넌트 다이어그램(Component Diagram)
  - 실제 구현 모듈인 컴포넌트간의 관계나 컴포넌트간의 인터페이스 표현
  - 구현 단계에서 사용됨
- 배치 다이어그램(Batch Diagram)
  - 결과물, 프로세서, 컴포넌트 등 물리적 요소들의 위치를 표현
  - 구현 단계에서 사용됨
- 복합체 구조 다이어그램(Composite Structure Diagram)
  - 클래스나 컴포넌트가 복함 구조를 갖는 경우 그 내부 구조를 표현
- 패키지 다이어그램(Package Diagram)
  - 유스케이스나 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계 표현

## 행위(Behavioural) 다이어그램의 종류
- 유스케이스 다이어그램(Use Case Diagram)
  - 사용자의 요구를 분석하는 것으로 기능 모델링 작업에 사용
  - 사용자(actor)와 사용 사례(Use Case)로 구성
- 순차 다이어그램(Sequence Diagram)
  - 상호 작용하는 시스템이나 객체들이 주고받는 메시지 표현
- 커뮤니케이션 다이어그램(Communication Diagram)
  - 동작에 참여하는 객체들이 주고받는 메시지와 객체들 간의 연관 관계 표현
- 상태 다이어그램(State Diagram)
  - 하나의 객체가 자신이 속한 클래스의 상태 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화하는지를 표현함
  - 럼바우 객체지향 분석 기법에서 동적 모델링에 사용됨
- 활동 다이어그램(Activity Diagram)
  - 시스템이 어떤 기능을 수행하는지 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서에 따라 표현
- 상호작용 개요 다이어그램(Interaction Overview Diagram)
  - 상호작용 다이어그램간의 제어 흐름 표현
- 타이밍 다이어그램(Timing Diagram)
  - 객체 상태 변화와 시간 제약을 명시적으로 표현

## 스테레오타입(Stereotype)
- **UML에서 표현하는 기본 기능 외에 추가적인 기능을 표현하는 것**
- 겹화살괄호(`<< >>`) 사이에 표현할 형태를 기술
- 주로 표현되는 형태
  - `<<include>>` : 연결된 다른 UML 요소에 포함 관계에 있는 경우
  - `<<extends>>` : 연결된 다른 UML 요소에 확장 관계에 있는 경우
  - `<<interface>>` :  인터페이스를 정의하는 경우
  - `<<exception>>` : 예외를 정의하는 경우
  - `<<constructor>>` : 생성자 역할을 수행하는 경우


# 012.유스케이스(Use Case) 다이어그램

## **기능 모델링**
- **개발될 시스템이 갖춰야 할 기능을 사용자와 공유하기 위해 그림으로 표현하는 것**
- 개발될 시스템의 전반적인 형태를 기능에 초점을 맞춰 표현
- 기능 모델링의 종류 : 유스케이스 다이어그램, 액티비티 다이어그램

## 유스케이스 다이어그램
- **개발될 시스템을 이용해 수행할 수 있는 기능을 사용자의 관점에서 표현한 것**
- 외부 요소와 시스템 간의 상호 작용을 확인할 수 있다 
- 사용자의 요구사항을 분석하기 위한 도구로 사용된다
- 시스템의 범위를 파악할 수 있다

## 유스케이스 다이어그램의 구성 요소
- 시스템/시스템 범위
  - 시스템 내부의 유스케이스들을 사각형으로 묶어 시스템의 범위를 표현한 것
- 액터
  - 시스템과 상호작용을 하는 모든 외부 요소
  - 주로 사람이나 외부 시스템 의미
  - 주액터 : 시스템을 사용함으로써 이득을 얻는 대상. 주로 사람이며 졸라맨으로 표시
  - 부액터 : 주액터의 목적 달성을 위해 시스템에 서비스를 제공하는 외부 시스템으로 조직이나 기관 등이 될 수 있음
- 유스케이스
  - 사용자가 보는 관점에서 시스템이 액터에게 제공하는 서비스나 기능을 표현하는 것
  - 주로 타원으로 표시
- 관계
  - 유스케이스 다이어그램에서 관계는 액터/유스케이스, 유스케이스/유스케이스 사이에어 발생 가능
  - 포함(···>), 확장(<···), 일반화 관계(◁-)


# 013.활동(Activity) 다이어그램

## 활동 다이어그램
- **사용자의 관점에서 시스템이 수행하는 기능을 처리 흐름에 따라 순서대로 표현한 것**
- 하나의 유스케이스 안에서 혹은 여러 유스케이스 사이에 발생하는 복잡한 처리의 흐름을 명확하게 표현할 수 있다
- 자료 흐름도와 유사

## 활동 다이어그램의 구성 요소
- 액션 / 액티비티
  - 액션 : 더 이상 분해할 수 없는 단일 작업
  - 액티비티 : 몇 개의 액션으로 분리될 수 있는 작업
- 시작 노드 : 액션이나 액티비티가 시작됨을 표현한 것
- 종료 노드 : 액티비티 안의 모든 흐름이 종료됨을 표현하는 것
- 조건(판단)노드
  - 조건에 따라 제어의 흐름이 분리됨을 표현
  - 조건의 입력은 하나이나 출력은 여러 개
- 병합 노드
  - 여러 경로의 흐림이 하나로 합쳐짐을 표현
  - 병합의 입력은 여러개이나 출력은 하나
- 포크 노드
  - 액티비티의 흐름이 분리되어 수행됨을 표현
- 조인 노드
  - 분리되어 수행되던 액티비티의 흐름이 다시 합쳐짐을 표현
- 스윔 레인
  - 액티비티 수행을 담당하는 주체를 구분하는 선
  - 실선으로 표현


# 014.클래스 다이어그램

## **정적 모델링**
- **사용자가 요구한 기능을 구현하는 덱 필요한 자료들의 논리적인 구조를 표현한 것**
- 시스템에 의해 처리되거나 생성될 객체들 사이에 어떤 관련이 있는지를 구조적인 관점에서 표현
- 객체들을 클래스로 추상화하여 표현
- UML을 이용한 정적 모델링의 대표적인 것

## 클래스 다이어그램
- **클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현한 것**
- 시스템을 구성하는 요소에 대해 이해할 수 있는 구조적 다이어그램
- 시스템 구성 요소를 문서화하는데 사용됨

## 클래스 다이어그램의 구성 요소
- 클래스
  - 각각의 객체들이 갖는 속성과 오퍼레이션을 표현한 것
  - 일반적으로 3개의 구획으로 나눠 클래스의 이름, 속성, 오퍼레이션을 표기함
  - 속성은 클래스의 상태나 정보를, 오퍼레이션은 클래스가 수행할 수 있는 동작을 뜻함
- 제약조건
  - 속성에 입력될 값에 대한 제약조건이나 오퍼레이션의 수정 전후에 지정해야 할 조건
  - 클래스 안에서 제약조건을 기술할 때에는 중괄호(`{ }`)를 사용
- 관계
  - 클래스와 클래스 사이의 연관성 표현
  - 클래스 다이어그램에서 표현하는 관계에는 연관, 집압, 포함, 일반화, 의존 관계가 있음

## 연관 클래스
- **연관 관계에 있는 두 클래스에 추가적으로 표현해야 할 속성이나 오퍼레이션이 있는 경우 생성하는 클래스**
- 두 클래스의 연관 관계를 나타내는 선의 가운데로부터 점선을 연관 클래스에 이어 표시
- 연관 클래스의 이름은 연관 관게의 이름을 이용해 지정


# 015.순차(Sequence) 다이어그램

## **동적 모델링**
- **시스템의 내부 구성 요소들의 상태 변화 과정과 과정에서 발생하는 상호 작용을 표현한 것**
- 시스템 내부 구성 요소들간에 이루어지는 동작이라는 관점에서 표현
- 시스템이 실행될 때 구성 요소들 간의 메시지 호출, 즉 오퍼레이션을 통한 상호 작용에 초점을 둠
- 동적 모델링의 종류 : 순차 다이어그램, 커뮤니케이션 다이어그램, 상태 다이어그램

## 순차 다이어그램
- **시스템이나 객체들이 메시지를 주고받으며 상호 작용하는 과정을 그림으로 표현한 것**
- 각 동작에 참여하는 시스템이나 객체들의 수행 기간을 확인할 수 있음
- 클래스 내부에 있는 객체들을 기본 단위로 하여 그들의 상호 작용(오퍼레이션)을 표현

## 순차 다이어그램의 구성 요소
- 액터
  - 시스템으로부터 서비스를 요청하는 외부 요소, 사람이나 외부 시스템을 의미
- 객체
  - 메시지를 주고받는 주체
- 생명선
  - 객체가 메모리에 존재하는 기간으로, 객체 아래쪽에 점선을 그어 표현
  - 객체 소멸(X)이 표시된 기간까지 존재함
- 실행 상자
  - 객체가 메시지를 주고받으며 구동되고 있음을 표현
- 메시지
  - 객체가 상호 작용을 위해 주고받는 메시지
- 객체 소멸
  - 해당 객체가 더 이상 메모리에 존재하지 않음을 표현
- 프레임
  - 다이어그램의 전체 또는 일부를 묶어 표현한 것


# 커뮤니케이션(Communication) 다이어그램

## 커뮤니케이션 다이어그램
- **시스템이나 객체들이 메시지를 주고받으며 상호작용하는 과정과 객체들 간의 연관을 그림으로 표현한 것**
- 동작에 참여하는 객체들 사이의 관계를 파악하는 데 사용
- 관계가 제대로 표현되었는지 점검하는 용도로도 사용
- 초기에는 협업 다이어그램이라고 불렸음

## 커뮤니케이션 다이어그램의 구성 요소
- 액터
  - 시스템으로부터 서비스를 요청하는 외부 요소로, 사람이나 외부 시스템을 의미
- 객체
  - 메시지를 주고받는 주체
- 링크
  - 객체들 간의 관계를 표현한 것
  - 액터와 객체, 객체와 객체 간에 실선을 그어 표현
- 메시지
  - 객체가 상호 작용을 위해 주고받는 내용
  - 화살표의 방향은 메시지를 받는 쪽으로 향하게 표현
  - 일정한 순서에 의해 처리되는 메시지의 경우 숫자로 순서 표시


# 017.상태(State) 다이어그램

## 상태 다이어그램
- **객체들 사이에서 발생하는 이벤트에 의해 객체들의 상태 변화를 그림으로 표현한 것**
- 객체의 상태란 객체가 갖는 속성값의 변화를 의미
- 특정 객체가 어떤 이벤트에 의해 상태 변환 과정이 진행되는지 확인하는 데 사용
- 시스템에서 상태 변환 이벤트를 확인할 필요가 있는 객체만을 대상으로 그림

## 상태 다이어그램 구성 요소
- 상태
  - 객체의 상태를 표현한 것
  - 굽은 직사각형으로 표현
- 시작 상태
  - 상태의 시작을 표현한 것
  - 속이 찬 원으로 표현
- 종료 상태
  - 상태의 종료를 표현한 것
  - 이중 원으로 표현
- 상태 전환
  - 상태 사이의 흐름, 변화를 화살표로 표현한 것
- 이벤트
  - 상태에 변화를 주는 현상
  - 이벤트에는 조건, 외부 신호, 시간의 흐름 등이 있음
- 프레임
  - 상태 다이어그램의 범위를 표현한 것


# 018.패키지(Package) 다이어그램

## 패키지 다이어그램
- 유스케이스나 클래스 등의 **요소들을 그룹화한 패키지간의 의존 관계를 표현한 것**
- 또 다른 패키지의 요소가 될 수 있음
- 대규모 시스템에서는 주요 요소 간의 종속성을 파악하는데 사용

## 패키지 다이어그램 구성 요소
- 패키지
  - 객체들을 그룹화한 것
  - 단순 표기법 : 패키지 안에 패키지 이름만 표현
  - 확장 표기법 : 패키지 안에 요소까지 표현
- 객체
  - 유스케이스, 클래스, 인터페이스, 테이블 등 패키지에 포함될 수 있는 다양한 요소들
- 의존 관계
  - 패키지와 패키지, 패키지와 객체 간을 점선 화살표로 연결하여 표현
  - 스테레오타입을 이용해 의존 관계를 구체적으로 표현할 수 있음
  - 의존 관계의 표현 형태는 사용자가 임의로 작성할 수 있으며 대표적으로 import와 access가 사용됨
    - `<<import>>` : 패키지에 포함된 객체들을 직접 가져와서 이용하는 관계
    - `<<access>>` : 인터페이스를 통해 패키지 내의 객체에 접근하여 이용하는 관계


# 019.소프트웨어 개발 방법론

## 소프트웨어 개발 방법론
- **소프트웨어 개발, 유지보수 등에 팰이효나 여러 가지 일들의 수행 방법과 이러한 일들을 효율적으로 수행하련는 과정에서 필요한 각종 기법 및 도구를 체계적으로 정리하여 표준화한 것**
- 소프트웨어의 품질 향상이 목적이다
- 주요 소프트웨어 개발 방법론 : 구조적, 정보공학, 객체지향, 컴포넌트 기반, 제품 계열, 애자일

## 구조적 방법론
- 정형화된 분석 절차에 따라 **사용자 요구사항을 파악하여 문서화하는 처리 중심의 방법론**
- 1960년대까지 가장 많이 적용되었던 소프트웨어 개발 방법론
- 쉬운 이해 및 검증이 가능한 코드 생성이 목적
- 복잡한 문제를 다루기 위해 분할과 정복 원리를 적용
- 구조적 방법론의 개발 절차 : 타당성 검토 -> 계획 단계 -> 요구사항 단계 -> 설계 단계 -> 구현 단계 -> 시험 단계 -> 운용/유지보수 단계

## 정보공학 방법론
- **계획, 분석, 설계, 구축에 정형화된 기법들을 상호 연관성 있게 통합 및 적용하는 자료 중심의 방법론**
- 정보 시스템 개발 주기를 이용해 대규모 정보 시스템을 구축하는데 적합
- 정보공학 방법론의 개발 절차 : 정보 전략 계획 수립 -> 업무 영역 분석 -> 업무 시스템 설게 -> 업무 시스템 구축

## 객체지향 방법론
- 현실 세게의 개체를 기계의 부품처럼 하나의 객체로 만들어, 소프트웨어를 개발할 때 기계의 부품을 조립하듯이 **객체들을 조립해 필요한 소프트웨어를 구현하는 방법론**
- 구조적 기법의 문제점으로 인한  소프트웨어 위기의 해결책으로 채택되었음
- 객체지향 방법론의 구성 요소 : 객체, 클래스, 메시지 등
- 객체지향 방법론의 기본 원칙 : 캡슐화, 정보 은닉, 추상화, 상속성, 다형성 등
- 객체지향 방법론의 개발 절차 : 요구분석 -> 설계 -> 구현 -> 테스트 및 검증 -> 인도

## 컴포넌트 기반 방법론
- 기존의 시스템이나 소프트웨어를 구성하는 **컴포넌트를 조합하여 하나의 새로운 애플리케이션을 만드는 방법론**
- 컴포넌트의 재사용이 가능하여 시간과 노력을 절감할 수 있다.
- 새로운 기능을 추가하는 것이 간단하여 확장성이 보장된다
- 유지 보수 비용을 최소화하고 생산성 및 품질을 향상시킬 수 있다.
- 컴포넌트 기반 방법론의 개발 절차 : 개발 준비 -> 분석 -> 설계 -> 구현 -> 테스트 -> 전개 -> 인도

## 제품 계열 방법론
- **특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론**
- 임베디드 소프트웨어를 만드는데 적합
- 저품 계열 방법론은 영역공학과 응용공학으로 구분됨
  - 영역공학 : 영역 분석, 영역 설계, 핵심 자산을 구현하는 영역
  - 응용공학 : 제품 요구 분석, 제품 설계, 제품을 구현하는 영역
- 영역공학과 응용공학의 연계를 위해 제품의 요구사항, 아키텍처, 조립이 필요


# 020.SW공학의 발전적 추세

## 소프트웨어 재사용
- **이미 개발되어 인정받은 소프트웨어를 다른 소프트웨어 개발이나 유지에 사용하는 것**
- 소프트웨어 개발의 품질과 생산성을 높이기 위한 방법
- 기존에 개발된 소프트웨어와 경험, 지식 등을 새로운 소프트웨어에 적용
- 소프트웨어 재사용 방법
  - 합성 중심 : 소프트웨어 부품, 즉 블록을 만들어서 끼워 맞춰 소프트웨어를 완성시키는 방법, 블록 구성 방법이라고도 함
  - 생성 중심 : 추상화 형태로 서진 명세를 구체화하여 프로그램을 만드는 방법, 패턴 구성 방법이라고도 함

## 소프트웨어 재공학
- 새로운 요구에 맞도록 **기존 시스템을 이용하여 보다 나은 시스템을 구축하고, 새로운 기능을 추가하여 소프트웨어 성능을 향상시키는 것**
- 유지보수 비용이 소프트웨어 개발 비용의 대부분을 차지하기 때문에 유지보수의 생산성 향상을 통해 소프트웨어 위기를 해결하는 방법
- 기존 소프트웨어의 데이터와 기능들의 개조 및 개선을 통해 유지보수성과 품질을 향상시킨다
- 소프트웨어 재공학의 이점 : 품질 향상, 생산성 증가, 수명 연장, 오류 감소

## CASE(Computer Aided Software Engineering)
- **소프트웨어 개발 과정에서 사용되는 요구 분석, 설계, 구현, 검사 및 디버깅 과정 전체 또는 일부를 컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화하는 것**
- 다양한 시스템에서 활용되는 자동화 도구이다
- 소프트웨어 생명 주기의 전체 단계를 연결하고 자동화하는 통합된 도구를 제공
- 소프트웨어 개발 도구와 방법론이 결합되었으며, 정형화된 구조 및 방법을 소프트웨어 개발에 적용하여 생산성 향상을 구현
- CASE의 주요 기능 : 소프트웨어 생명 주기 전 단계의 연결, 다양한 소프트웨어 개발 모형 지원, 그래픽 지원


# 021.비용 산정 기법-하향식

## 하향식 비용 산정 기법
- **과거의 유사한 경험을 바탕으로 전문 지식이 많은 개발자들이 참여한 회의를 통해 비용을 산정하는 방법**
- 프로젝트 전체 비용을 산정한 후 각 작업별로 비용을 세분화함
- 하양식 비용 산정 기법의 종류 : 전문가 감정 기법, 델파이 기법

## 전문가 감정 기법
- **경험이 많은 두 명 이상의 전문가에게 비용 산정을 의뢰하는 기법**
- 가장 편리하고 신속하게 비용을 산정할 수 있다
- 의뢰자로부터 믿음을 얻을 수 있다
- 개인적이고 주관적일 수 있다

## 델파이 기법
- **전문가 감정 기법의 주관적인 편견을 보완하기 위해 많은 전문가의 의견을 종합하여 산정하는 기법**
- 전문가들의 편견이나 분위기에 지배되지 않도록 한 명의 조정자와 여러 전문가로 구성됨


# 022.비용 산정 기법-상향식

## 상향식 비용 산정 기법
- **프로젝트의 세부적인 작업 단위별로 비용을 산정한 후 집계하여 전체 비용을 산정하는 방식**
- 주요 상향식 비용 산정 기법 : LOC(원시 코드 라인 수) 기법, 개발 단계별 인월수 기법, 수학적 산정 기법

## LOC(source Line Of Code)기법
- **각 기능의 원시 코드 라인 수의 비관치, 낙관치, 기대치를 측정하여 예측치를 구하고 이를 이용하여 비용을 산정하는 기법**
- 측정이 용이하고 이해하기 쉬워 가장 많이 사용됨
- 예측치를 이용해 생산성, 노력, 개발 기간 등의 비용을 산정
  - `예측치 = (낙관치 + 기대치 * 4 + 비관치) / 6`
- 산정 공식
  - `노력(인월) = 개발 기간 * 투입 인원 = LOC / 1인당 월평균 생산 코드 라인 수`
  - `개발 비용 = 노력(인월) * 단위 비용(1인당 월평균 인건비)`
  - `개발 기간 = 노력(인월) / 투입 인원`
  - `생산성 = LOC / 노력(인월)`

## 개발 단계별 인월수 기법
- LOC기법을 보완하기 위한 기법으로 **각 기능을 구현시키는 데 필요한 노력을 생명 주기의 각 단계별로 선정**


# 023.수학적 산정 기법

## 수학적 산정 기법
- 상향식 비용 산정 기법으로 경험적 추정 모형, 실험적 추정 모형이라고도 함
- 개발 비용 산정의 자동화를 목표로 함
- 비용의 자동산정을 위해 사용되는 공식은 과거의 유사한 프로젝트를 기반으로 유도된 것
- 주요 수학적 산정 기법 : COCOMO 모형, Putnam 모형, 기능 점수(FP) 모형

## COCOMO(COnstructive COst MOdel)
- **LOC에 의한 비용 산정 기법**
- 개발할 소프트웨어의 규모를 예측한 후 이를 소프트웨어의 종류에 따라 다르게 책정되는 비용 산정 방정식을 대입
- 비용 산정 결과는 프로젝트를 완성하는 데 필요한 노력(Man-Month)으로 나타냄
- 보헴이 제안

## COCOMO의 소프트웨어 개발 유형
- 조직형(Organic Mode)
  - 기관 내부에서 개발된 중/소규모의 소프트웨어
  - 일괄 자료 처리나 과학기술 계산, 비즈니스 자료 처리용 등의 5만 라인 이하의 소프트웨어를 개발하는 유형
  - 사무 처리용, 업무용, 과학용 응용 소프트웨어 개발에 적합
- 반분리형(Semi-Detached Mode)
  - 조직형과 내장형의 중간형 소프트웨어
  - 트랜잭션 처리 시스템이나 운영체제, 데이터베이스 관리 시스템 등 30만 라인 이하의 소프트웨어 개발에 사용하는 유형
  - 컴파일러, 인터프리터와 같은 유틸리티 개발에 적합
- 내장형(Embedded Mode)
  - 초대항 규모의 소프트웨어
  - 트랜잭션 처리 시스템이나 운영체제 등의 30만 라인 이상의 소프트웨어를 개발하는 유형
  - 신호기 제어 시스템, 미사일 유도 시스템, 실시간 처리 시스템 등의 시스템 프로그램 개발에 적합

## COCOMO 모형의 종류
- 기본형 (Basic)
  - 소프트웨어 크기와 개발 유형만을 이용하여 비용 산정
- 중간형 (Intermeidate)
  - 기본형의 공식을 토대로 사용하나 다음 4가지 특성에 의해 비용 산정
  - 제품의 특성, 컴퓨터의 특성, 개벌 요원의 특성, 프로젝트 특성
- 발전형 (Detailed)
  - 중간형을 보완하여 만들어진 모형
  - 개발 공정별로 보다 자세하고 정확하게 노력을 산출하여 비용 산정
  - 소프트웨어 환경과 구성 요소가 사전에 정의되어 있어야 하며, 개발 과정의 후반부에 주로 적용

## Putnam 모형
- **소프트웨어 생명 주기의 전 과정 동안 사용될 노력의 분포를 예상하는 모형**
- Putnam이 제안한 것으로, 생명 주기 예측 모형이라고도 함
- 시간에 따른 함수로 표현되는 Raleigh-Norden속선의 노력 분포도를 기초로 함
- 대형 프로젝트의 노력 분포 산정에 이용됨
- 개발 기간이 늘어날수록 프로젝트 적용 인원의 노력이 감소됨

## 기능 점수(FP; Function Point) 모형
- **소프트웨어의 기능을 증대시키는 요인별로기능 점수를 구한 후 이를 이용해 비용을 산정하는 기법**
- 소프트웨어 기능 증대 요인 : 자료 입력(입력 양식), 정보 출력(출력 보고서), 명령어(사용자 질의수), 데이터 파일, 필요한 외부 루틴과의 인터페이스

## 비용 산정 자동화 추정 도구
- SLIM, ESTIMACS


# 024.프로젝트 일정 계획

## 프로젝트 일정 계획
- 프로젝트의 프로세스를 이루는 소작업을 파악하고 예측된 노력을 각 소작업에 분배하여 소작업의 순서와 일정을 정하는 것
- 프로젝트 일정 계획에 사용되는 기능 : WBS, PERT/CPM, 간트 차트 등

## PERT(Program Evaluation and Review Technique, 프로그램 평가 및 검토 기술)
- **전체 작업의 상호 관계를 표시하는 네트워크**
- 각 작업별로 다음과 같이 단계를 나누어 종료시기 결정
  - 낙관적인 경우
  - 가능성이 있는 경우
  - 비관적인 경우
- 개발 경험이 없어 소요 기간 예측이 어려운 프로젝트 일정 계획에 사용됨
- 노드와 간선으로 구성되며 원 노드에는 작업을, 간선에는 낙관치, 기대치, 비관치 표시
- 결정 경로, 작업에 대한 경계 시간, 작업 간의 상호 관련성 등을 알 수 있음
- 작업 예측치 계산 공식
  - `작업 예측치 = (낙관치 + 기대치 * 4 + 비관치) / 6`
  - `평방 편차 = ((비관치 - 낙관치) / 6)^2`

## CPM(Critical Path Method)
- **작업을 나열하고 작업에 필요한 소요 기간을 예측하는데 사용하는 기법**
- 노드와 간선으로 구성된 네트워크로 노드는 작업을 ,간선은 작업 사이의 전후 의존 관계를 나타냄
- 원형 노드는 각각의 작업을 의미하고 박스 노드는 이정표를 의미함
- 간선을 나타내는 화살표의 흐름에 따라 각 작업이 진행되며, 전 작업이 완료되어야 다음 작업을 진행할 수 있음

## 간트 차트
- **프로젝트의 작업 일정을 막대 도표를 이용하여 표시하는 프로젝트 일정표**
- 시간선 차트라고도 함
- 중간 목표 미달성 시 그 이유와 기간을 예측 가능
- 자원 배치와 인원 계획에 유용하게 사용
- 이정표, 작업 일정, 작업 기간, 산출물로 구성
- 수평 막대의 길이는 각 작업의 기간을 나타냄


# 025.소프트웨어 개발 방법론 결정

## 소프트웨어 개발 방법론 결정
- 프로젝트 관리와 재사용 현황을 소프트웨어 개발 방법론에 반영하고, 확정된 소프트웨어 생명 주기와 개발 방법론에 맞춰 소프트웨어 개발 단계, 활동, 작업 절차 등을 정의하는 것
- 소프트웨어 개발 방법론 결정 절차
  1. 프로젝트 관리와 재사용 현황을 소프트웨어 개발 방법론에 반영
  2. 개발 단계별 작업 및 절차를 소프트웨어 생명 주기에 맞춰 수립
  3. 결정된 소프트웨어 개발 방법론의 개발 단계별 활동 목적, 작업 내용, 산출물에 대한 매뉴얼 작성

## 프로젝트 관리
- **주어진 기간 내에 최소의 비용으로 사용자를 만족시키는 시스템을 개발하기 위한 전반적인 활동**
- 관리 유형 및 주요 내용
  - 일정 관리 : 작업 순서, 작업 기간 산정, 일정 개발, 일정 통제
  - 비용 관리 : 비용 산정, 비용 예산 편성, 비용 통제
  - 인력 관리 : 프로젝트 팀 편성, 자원 산정, 프로젝트 조직 정의, 프로젝트 팀 개발, 자원 통제, 프로젝트 팀 관리
  - 위험 관리 : 위험 식별, 위험 평가, 위험 대처, 위험 통제
  - 품질 관리 : 품질 계획, 품질 보증 수행, 품질 통제 수행


# 026.소프트웨어 개발 표준

## 소프트웨어 개발 표준
- **소프트웨어 개발 단계에서 수행하는 품질 관리에 사용되는 국제 표준**
- 주요 소프트웨어 개발 표준 : ISO/IEC 12207, CMMI, SPICE

## ISO/IEC 12207
- **ISO에서 만든 표준 소프트웨어 생명 주기 프로세스**
- 소프트웨어의 개발, 운영, 유지보수 등을 체계적으로 관리하기 위한 소프트웨어 생명 주기 표준 제공
- ISO/IEC 12207 구분
  - 기본 생명 주기 프로세스 : 획득, 공급, 개발, 운영, 유지보수 프로세스
  - 지원 생명 주기 프로세스 : 품질 보증, 검증, 확인, 활동 검토, 감사, 문서화, 형상관리, 문제 해결 프로젝트
  - 조직 생명 주기 프로세스 : 관리, 기반 구조, 훈련, 개선 프로세스

## CMMI(Capability Maturity Model Integration)
- **소프트웨어 개발 조직의 업무 능력 및 조직의 성숙도를 평가하는 모델**
- 미국 카네기멜론대 소프트웨어 공학연구소에서 개발
- CMMI 소프트웨어 프로세스 성숙도
  - 초기 : 관리된 프로세스 없음, 작업자 능력에 따라 성공 여부 결정
  - 관리 : 규칙화된 프로세스, 특정한 프로젝트 내의 프로세스 정의 및 수행
  - 정의 : 표준화된 프로세스, 조직의 표준 프로세스를 활용해 업무 수행
  - 정량적 관리 : 예측 가능한 프로세스, 프로젝트를 정량적으로 관리 및 통제
  - 최적화 : 지속적 개선 프로세스, 프로젝트 역량 향상을 위해 지속적인 프로세스 개선

## SPICE(Software Process Improvement and Capability dEtermination)
- **소프트웨어의 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준**
- 공식 명칭은 ISO/IEC 15504

## SPICE의 구성
- 고객-공급자 프로세스
  - 소프트웨어를 개발하여 고객에게 전달하는 것을 지원하고, 소프트웨어의 정확한 운용 및 사용을 위한 프로세스로 구성됨
  - 구성 요소 : 인수, 공급, 요구 도출, 운영
  - 프로세스 수 : 10개
- 공학 프로세스
  - 시스템과 소프트웨어 제품의 명세화, 구현, 유지보수를 하는데 사용되는 프로세스로 구성됨
  - 구성 요소 : 개발, 소프트웨어 유지보수
  - 프로세스 수 : 9개
- 지원 프로세스
  - 소프트웨어 생명 주기에서 다른 프로세스에 의해 이용되는 프로세스로 구성됨
  - 구성 요소 : 문서화, 형상, 품질 보증, 검증, 확인, 리뷰, 감사, 품질 문제 해결
  - 프로세스 수 : 8개
- 관리 프로세스
  - 소프트웨어 생명 주기에서 프로젝트 관리자에 의해 사용되는 프로세스로 구성됨
  - 구성 요소 : 관리, 프로젝트 관리, 품질 및 위험 관리
  - 프로세스 수 : 4개
- 조직 프로세스
  - 조직의 업무 목적 수립과 조직의 업무 목표 달성을 위한 프로세스로 구성됨
  - 구성 요소 : 조직 배치, 개선 활동 프로세스, 인력 관리, 기반 관리, 측정 도구, 재사용
  - 프로세스 수 : 9개

## SPICE의 프로세스 수행 단계 능력
- 불완전 : 프로세스가 구현되지 않았거나 목적을 달성하지 못한 단계
- 수행 : 프로세스가 수행되고 목적이 달성된 단계
- 관리 : 정의된 자원의 한도 내에서 그 프로세스가 작업 산출물을 인도하는 단계
- 확립 : 소프트웨어 공학 원칙에 기반하여 정의된 프로세스가 수행되는 단계
- 예측 : 프로세스가 목적 달성을 위해 통제되고, 양적인 측정을 통해서 일관되기 수행되는 단계
- 최적화 : 프로세스 수행을 최적화하고, 지속적인 개선을 통해 업무 목적을 만족시키는 단계


# 027.소프트웨어 개발 방법론 테일러링

## 소프트웨어 개발 방법론 테일러링
- **소프트웨어 개발 방법론의 절차, 사용기법 등을 수정 및 보완하는 작업**
- 수행 절차
  - 프로젝트 특징 정의
  - 표준 프로세스 선정 및 검증
  - 상위 수준의 커스터마이징
  - 세부 커스터마이징
  - 테일러링 문서화

## 소프트웨어 개발 방법론 테일러링 고려사항
- 내부적 기준
  - 목표 환경 : 시스템의 개발 환경과 유형이 서로 다른 경우
  - 요구사항 : 프로젝트의 생명 주기 활동에서 개발, 운영, 유지보수 등 프로젝트에서 우선적으로 고려할 요구사항이 서로 다른 경우
  - 프로젝트 규모 : 비용, 인력, 기간 등 프로젝트의 규모가 서로 다른 경우
  - 보유 기술 : 프로세스, 개발 방법론, 산출물, 구성원의 능력 등이 서로 다른 경우
-외부적 기준
  - 법적 제약상항 : 프로젝트별로 적용될 규제가 서로 다른 경우
  - 표준 품질 기준 : 분야별 표준 품질 기술이 서로 다른 경우


# 028.소프트웨어 개발 프레임워크

## 소프트웨어 개발 프레임워크
- **소프트웨어 개발에 공통적으로 사용되는 구성 요소와 아키텍처를 일반화하여 제공해주는 반제품 형태의 소프트웨어 시스템**
- 선행 사업자의 기술에 의존하지 않는 표준화된 개발 기반으로 인해 사업자 종속성이 해소됨
- 프레임워크의 주요 기능
  - 예외 처리
  - 트랜잭션 공유
  - 메모리 공유
  - 데이터 소스 관리
  - 서비스 관리
  - 쿼리 서비스
  - 로깅 서비스
  - 사용자 인증 서비스
- 소프트웨어 개발 프레임워크 종류
  - 스프링 프레임워크
  - 전자정부 프레임워크
  - 닷넷 프레임워크

## 스프링 프레임워크
- **자바 플랫폼을 위한 오픈 소스 경량화 애플리케이션 프레임워크**
- 동적 웹사이트의 개발을 위한 다양한 서비스 제공
- 전자정부 표준 프레임워크의 기반 기술로 사용됨

## 전자정부 프레임워크
- **대한민국의 공공부문 정보화 사업 시 정보시스템의 구축을 지원하기 위해 필요한 기능 및 아키텍처를 제공하는 프레임워크**
- 개발 프레임워크의 표준 정립으로 응용 소프트웨어의 표준화, 품질 및 재사용성의 향상을 목적으로 함
- 오픈 소스 기반의 범용화 이룩 가능
- 공개된 기술을 활용함으로써 특정 업체의 종속성을 배제하고 사업별 공통 컴포넌트의 중복 개발 방지

## 닷네 프레임워크
- **Windows 프로그램의 개발 및 실행 환경을 제공하는 프레임워크**
- MS에서 통합 인터넷 전략을 위해 개발
- 코드 실행을 관리하는 CLR 가상머신 상에서 작동

## 소프트웨어 개발 프레임워크의 특성
- 모듈화(Modularity)
  - 프레임워크는 캡슐화를 통해 모듈화를 강화하고 설계 및 구현의 변경에 따른 영향을 최소화함으로써 소프트웨어의 품질을 향상시킴
  - 프레임워크는 개발 표준에 의한 모듈화로 인해 유지보수가 용이함
- 재사용성(Reusability)
  - 프레임워크는 재사용 가능한 모듈들을 제공함으로써 예산 절감, 생산성 향상, 품질 보증이 가능함
- 확장성(Extensibility)
  - 프레임워크는 다형성을 통한 인터페이스 확장이 가능하여 다양한 형태와 기능을 가진 애플리케이션 개발이 가능함
- 제어의 역흐름(Inversion of Control)
  - 개발자가 관리하고 통제해야 하는 객체들의 제어를 프레임워크에 넘김으로써 생산성을 향상시킴



# 예상문제은행
1. 개발 시작 전 프로토타입을 제작함으로써 개발의 상황 및 결과를 미리 예측해보는 모형  
답 : 개발될 소프트웨어에 대한 견본품을 만들어 최종 결과물을 예측하는 모형
2. 소프트웨어 생명 주기 모형
3. 애자일
4. 스크럼
5. XP
6. 공동 소유 / 역할 분배  
답 : 짝 프로그래밍 / 전체 팀
7. B A C  
답 : C A B
8. 백업  
답 : 이중화
9. ㄱ ㄴ ㄷ / ㄹ
10. 프로그램이 요구하는 것들을 정리한 머시기  
답 : 요구사항을 정의하고 분석 및 관리하는 프로세스를 연구하는 학문
11. 정형 / 비정형
12. 최종적으로 정리된 요구사항을 이해관계자들에게 확인받는다  
답 : 요구사항 명세서가 정확하고 완전하게 작성되었는지 검토하는 활동
13. 요구사항 분석  
답 : 요구사항 도출
14. 자료 흐름 / 자료 저장소
15. 절차적 분석  
답 : 구조적 분석 기법
16. 요구사항을 컴퓨터 프로그램을 이용해 분석하는 것  
답 : 요구사항을 자동으로 분석하고 요구사항 분석 명세서를 기술하도록 개발된 도구
17. 몰루  
답 : 가시적 도표 / 총체적 도표 / 세부적 도표
18. ㄹ / ㄷ / ㄴ / ㄱ
19. 관계 / 오퍼레이션 / 클래스  
답 : 관계 / 클래스 / 인터페이스
20. 일반화 관계
21. 의존 / 연관  
답 : `<<include>>` / `<<extends>>`
22. 카드발급 신청 / 신용 양호 / 인증 재시도
23. 주석  
답 : 제약조건
24. 두 클래스간에 데이터를 주고받을 때 통합되는 데이터들을 관리하기 위한 클래스  
답 : 연관 관계에 있는 클래스 사이에 추가적으로 표현해야 할 속성이나 오퍼레이션이 있는 경우 생성하는 클래스
25. 신청할 카드 선택  
답 : 신청생성
26. Lifeline, Active Box, Message  
답 : Object, Lifeline, Active Box, Message, Frame
27. 시간선  
답 : 생명선
28. 로그인화면, 카드선택화면, 카드:신규신청, 신용:신용확인 화면
29. 본인정보 입력 / 인증 재시도 / 정보 불일치 / 정보 일치
30. 클래스 기반 방법론  
답 : 객체지향 방법론
31. 분석 / 검증  
답 : 업무 영역 분석 / 업무 시스템 설계
32. 이전에 만들어진 소프트웨어를 재사용하여 개발 비용 및 인력을 아끼는 일  
답 : 이미 개발되어 인정받은 소프트웨어를 다른 소프트웨어 개발이나 유지에 사용하는 것
33. LOC 기법
34. 소프트웨어 재공학
35. 36000 / (6 * 400) = 15
36. 조직형 / 반분리형 / 임베디드형 (내장형)
37. Putnam
38. 원시형 / 발전형  
답 : 기본형 / 발전형
39. 몰루  
답 : CPM
40. 구현 / 몰 / 루  
답 : 수행 / 확립 / 예측
41. 18일
42. 자원 관리 / 시간 관리  
답 : 인력 관리 / 일정 관리
43. 소프트웨어의 개선 및 유지보수에 대한 국제 표준  
답 : 소프트웨어 품질 및 생상선 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준
44. 개발 프로세스 / 연계 프로세스  
답 : 공학 프로세스 / 지원 프로세스
45. 개발 / 표준  
답 : 프로젝트 / 표준 품질
46. 한국정보 프레임워크  
답 : 전자정부 프레임워크
47. 닷넷 프레임워크